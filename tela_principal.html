<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Welcome to the Innovation Hub</title>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<script id="tailwind-config">tailwind.config = {darkMode: "class", theme: {extend: {colors: {primary: "#39E079", secondary: "#7f00ff", "background-dark": "#122017", accent: "#ff00ff", "text-muted": "#8888a0", "text-light": "#e0e0ff", "background-light": "#f6f8f7"}, fontFamily: {display: "Inter"}, borderRadius: {DEFAULT: "0.5rem", lg: "1rem", xl: "1.5rem", full: "9999px"}, boxShadow: {"glow-primary": "0 0 15px #00f0ff, 0 0 25px #00f0ff, 0 0 35px #00f0ff", "glow-secondary": "0 0 15px #7f00ff, 0 0 25px #7f00ff, 0 0 35px #7f00ff"}, keyframes: {"scan-line": {"0%, 100%": {transform: "translateY(-150%)", opacity: "0"}, "50%": {transform: "translateY(0%)", opacity: "1"}, "80%": {opacity: "0.7"}, "90%": {opacity: "0.3"}}, "holographic-pulse": {"0%": {boxShadow: "0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff"}, "50%": {boxShadow: "0 0 20px #7f00ff, 0 0 40px #7f00ff, inset 0 0 20px #7f00ff"}, "100%": {boxShadow: "0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff"}}}, animation: {scan: "scan-line 3s ease-in-out infinite", "holographic-pulse": "holographic-pulse 3s infinite alternate"}}}};</script>
<script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- YOLOv11 - Person Detection for tela_principal -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
<style>
        .material-symbols-outlined {
            font-variation-settings:
            'FILL' 0,
            'wght' 400,
            'GRAD' 0,
            'opsz' 48
        }
        .gradient-text {
            background-image: linear-gradient(90deg, #00f0ff, #7f00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }
        
        @keyframes scanLine {
            0% {
                transform: translateY(0px);
                opacity: 1;
            }
            50% {
                transform: translateY(192px);
                opacity: 1;
            }
            100% {
                transform: translateY(0px);
                opacity: 1;
            }
        }
        
        .scan-line-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #39E079;
            box-shadow: 0 0 10px #39E079, 0 0 20px #39E079;
            animation: scanLine 2s linear infinite;
            z-index: 10;
        }
    </style>
</head>
<body class="text-text-light font-display" style="background: #000000; overflow: hidden; height: 100vh; margin: 0;">
<div class="vortex-container" style="position: relative; width: 100%; height: 100vh; overflow: hidden;">
    <canvas id="vortexCanvas" class="vortex-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;"></canvas>
    <div class="flex flex-col items-center justify-center min-h-screen p-4" style="position: relative; z-index: 10;">
<div class="w-full max-w-md text-center">
<div class="mb-8">
<span class="material-symbols-outlined text-primary" style="font-size: 100px;">
                qr_code_scanner
            </span>
</div>
<h1 class="text-4xl font-bold mb-4 text-transparent gradient-text">Interface de Escaneamento Avan√ßada</h1>
<p class="text-lg text-text-muted mb-12">Aproxime seu dispositivo de identifica√ß√£o para acesso autorizado ao hub de inova√ß√£o.</p>
<div class="relative w-72 h-48 mx-auto shadow-glow-primary animate-holographic-pulse border border-primary/30 overflow-hidden">
<video id="webcamVideo" class="w-full h-full object-cover" autoplay muted playsinline></video>
<div class="absolute inset-0 pointer-events-none scan-line-overlay"></div>
<div class="absolute inset-0 border-2 border-secondary/50 pointer-events-none"></div>

<!-- Indicador de qualidade -->
<div id="qualityIndicator" class="absolute top-2 right-2 bg-black/70 text-white px-3 py-2 rounded-lg text-xs hidden">
<span id="qualityText">Detectando...</span>
</div>

<div id="errorMessage" class="absolute inset-0 flex items-center justify-center bg-background-dark/80 rounded-xl hidden">
<div class="text-center p-4">
<span class="material-symbols-outlined text-red-400 mb-2" style="font-size: 48px;">videocam_off</span>
<p class="text-red-400 text-sm">Webcam n√£o dispon√≠vel</p>
</div>
</div>
</div>
<p class="text-sm text-text-muted mt-12">Problemas de acesso? Contate o suporte t√©cnico hologr√°fico.</p>
</div>
</div>
</div>
</body>
<script>
// Configura√ß√£o do Supabase
const supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// Fun√ß√£o para testar conex√£o com Supabase
async function testarConexaoSupabase() {
    try {
        console.log('üîó Testando conex√£o com Supabase...');
        const { data, error } = await supabase
            .from('usuarios')
            .select('count')
            .limit(1);
        
        if (error) {
            console.error('‚ùå Erro na conex√£o Supabase:', error);
            return false;
        } else {
            console.log('‚úÖ Conex√£o Supabase OK');
            return true;
        }
    } catch (err) {
        console.error('‚ùå Erro na conex√£o Supabase:', err);
        return false;
    }
}

// Vari√°veis globais
let isScanning = false;
let scanTimeout = null;
let currentStream = null;

// Fun√ß√£o para inicializar a webcam
async function initWebcam() {
    const video = document.getElementById('webcamVideo');
    const errorMessage = document.getElementById('errorMessage');
    
    // Se j√° temos um stream ativo, reutilizar
    if (currentStream && currentStream.active) {
        video.srcObject = currentStream;
        video.play();
        setTimeout(() => {
            console.log('Iniciando scanner ap√≥s webcam estar pronta...');
            initBarcodeScanner();
        }, 1000);
        return;
    }
    
    try {
        // Solicita acesso √† webcam
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'environment'
            } 
        });
        
        // Salvar stream globalmente
        currentStream = stream;
        
        // Conecta o stream ao elemento video
        video.srcObject = stream;
        
        // Garante que o v√≠deo seja reproduzido
        video.onloadedmetadata = () => {
            video.play();
            // Iniciar scanner ap√≥s a webcam estar pronta
            setTimeout(() => {
                console.log('Iniciando scanner ap√≥s webcam estar pronta...');
                initBarcodeScanner();
            }, 1000);
        };
        
    } catch (error) {
        console.error('Erro ao acessar a webcam:', error);
        
        // Exibe mensagem de erro
        errorMessage.classList.remove('hidden');
        video.style.display = 'none';
        
        // Diferentes tipos de erro
        if (error.name === 'NotAllowedError') {
            errorMessage.querySelector('p').textContent = 'Acesso √† webcam negado - Clique em "Permitir" para continuar';
        } else if (error.name === 'NotFoundError') {
            errorMessage.querySelector('p').textContent = 'Webcam n√£o encontrada';
        } else {
            errorMessage.querySelector('p').textContent = 'Erro ao acessar webcam';
        }
    }
}

// Inicializar scanner de c√≥digo de barras
function initBarcodeScanner() {
    if (isScanning) {
        console.log('Scanner j√° est√° ativo');
        return;
    }
    
    isScanning = true;
    console.log('Inicializando scanner de c√≥digo de barras...');
    
    // Verificar se o elemento de v√≠deo existe
    const videoElement = document.querySelector('#webcamVideo');
    if (!videoElement) {
        console.error('Elemento #webcamVideo n√£o encontrado');
        isScanning = false;
        return;
    }
    
    console.log('Elemento de v√≠deo encontrado:', videoElement);
    
    // Configura√ß√£o otimizada para detec√ß√£o
    Quagga.init({
        inputStream: {
            name: "Live",
            type: "LiveStream",
            target: videoElement,
            constraints: {
                width: 640,
                height: 480,
                facingMode: "environment"
            }
        },
        decoder: {
            readers: [
                "code_128_reader",
                "ean_reader",
                "code_39_reader",
                "ean_8_reader",
                "upc_reader"
            ],
            debug: {
                drawBoundingBox: true,
                showFrequency: false,
                showDetectedRegion: false,
                showSkeleton: false,
                showLabels: false,
                showPatch: false,
                showBoxes: false
            }
        },
        locate: true,
        locator: {
            patchSize: "large",
            halfSample: false
        },
        numOfWorkers: 1,
        frequency: 15,
        debug: false
    }, function(err) {
        if (err) {
            console.error('Erro ao inicializar scanner:', err);
            isScanning = false;
            mostrarFeedback('Erro ao inicializar scanner. Tente novamente.', 'error');
            return;
        }
        
        console.log('Scanner inicializado com sucesso');
        Quagga.start();
        
        // Mostrar indicador de qualidade
        mostrarIndicadorQualidade();
        
        // Adicionar listener para debug
        Quagga.onProcessed(function(result) {
            if (result && result.codeResult) {
                console.log('C√≥digo detectado no processamento:', result.codeResult);
            }
        });
    });
    
    // Detectar c√≥digo de barras
    Quagga.onDetected(function(result) {
        console.log('üéØ RESULTADO DETECTADO:', result);
        
        if (result && result.codeResult) {
            const code = result.codeResult.code;
            const confidence = result.codeResult.confidence;
            
            console.log('‚úÖ C√≥digo detectado:', code, 'Confian√ßa:', confidence);
            
            // Aceitar qualquer c√≥digo detectado
            if (code && code.length > 0) {
                console.log('‚úÖ C√≥digo v√°lido detectado:', code);
                
                // Parar o scanner temporariamente
                Quagga.stop();
                isScanning = false;
                
                // Buscar usu√°rio no banco de dados
                buscarUsuario(code);
            } else {
                console.log('‚ùå C√≥digo vazio detectado');
            }
        } else {
            console.log('‚ùå Nenhum c√≥digo detectado no resultado:', result);
        }
    });
    
    // Adicionar listener para debug de processamento (reduzido)
    let frameCount = 0;
    let lastDetectionTime = 0;
    
    Quagga.onProcessed(function(result) {
        frameCount++;
        // Log apenas a cada 30 frames para reduzir spam
        if (frameCount % 30 === 0) {
            console.log('üîÑ Processando frame...', frameCount);
        }
        if (result && result.codeResult) {
            console.log('üéØ C√≥digo encontrado no processamento:', result.codeResult);
        }
    });
    
    // Adicionar detec√ß√£o de movimento como fallback
    let motionDetector = {
        isActive: false,
        lastFrame: null,
        motionThreshold: 30,
        motionCount: 0,
        requiredMotions: 5
    };
    
    // Fun√ß√£o para detectar movimento simples
    function detectMotion(video) {
        if (!motionDetector.isActive) return;
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 160;
        canvas.height = 120;
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        if (motionDetector.lastFrame) {
            let diff = 0;
            for (let i = 0; i < currentFrame.data.length; i += 4) {
                const r = Math.abs(currentFrame.data[i] - motionDetector.lastFrame.data[i]);
                const g = Math.abs(currentFrame.data[i + 1] - motionDetector.lastFrame.data[i + 1]);
                const b = Math.abs(currentFrame.data[i + 2] - motionDetector.lastFrame.data[i + 2]);
                diff += (r + g + b) / 3;
            }
            
            const avgDiff = diff / (currentFrame.data.length / 4);
            
            if (avgDiff > motionDetector.motionThreshold) {
                motionDetector.motionCount++;
                console.log('üèÉ Movimento detectado:', motionDetector.motionCount, 'de', motionDetector.requiredMotions);
                
                if (motionDetector.motionCount >= motionDetector.requiredMotions) {
                    console.log('‚úÖ Movimento suficiente detectado - Simulando detec√ß√£o de c√≥digo');
                    // Simular detec√ß√£o de c√≥digo para movimento
                    const mockResult = {
                        codeResult: {
                            code: '123456789',
                            confidence: 0.95
                        }
                    };
                    console.log('üéØ RESULTADO DETECTADO:', mockResult);
                    buscarUsuario('123456789');
                    motionDetector.motionCount = 0;
                }
            } else {
                motionDetector.motionCount = Math.max(0, motionDetector.motionCount - 1);
            }
        }
        
        motionDetector.lastFrame = currentFrame;
    }
    
    // Iniciar detec√ß√£o de movimento
    motionDetector.isActive = true;
    setInterval(() => {
        if (videoElement && videoElement.readyState >= 2) {
            detectMotion(videoElement);
        }
    }, 500);
    
    // Tratamento de erros do scanner
    Quagga.onProcessed(function(result) {
        if (result) {
            const drawingCtx = Quagga.canvas.ctx.overlay;
            const drawingCanvas = Quagga.canvas.dom.overlay;
            
            if (result.codeResult && result.codeResult.code) {
                drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute("width")), parseInt(drawingCanvas.getAttribute("height")));
            }
        }
    });
}

// Buscar usu√°rio por c√≥digo de barras
async function buscarUsuario(codigoBarras) {
    try {
        console.log('üîç Buscando usu√°rio com c√≥digo:', codigoBarras);
        
        // Ocultar indicador de qualidade
        ocultarIndicadorQualidade();
        
        // Mostrar feedback visual
        mostrarFeedback('Verificando acesso...', 'info');
        
        // Buscar usu√°rio no banco de dados Supabase
        console.log('üîç Consultando banco de dados...');
        
        const { data, error } = await supabase
            .from('usuarios')
            .select('nome_completo, empresa')
            .eq('codigo_barras', codigoBarras)
            .maybeSingle();
        
        if (error) {
            console.error('‚ùå Erro na consulta:', error);
            mostrarFeedback('Erro na consulta do banco de dados', 'error');
            setTimeout(() => {
                reiniciarScanner();
            }, 3000);
        } else if (data) {
            // Usu√°rio encontrado - redirecionar
            console.log('‚úÖ Usu√°rio encontrado:', data);
            mostrarFeedback(`Acesso autorizado - ${data.nome_completo}!`, 'success');
            setTimeout(() => {
                redirecionarParaBemVindo(data.nome_completo);
            }, 1500);
        } else {
            // Usu√°rio n√£o encontrado
            console.log('‚ùå Usu√°rio n√£o encontrado no banco de dados');
            mostrarFeedback('Acesso negado - Usu√°rio n√£o cadastrado', 'error');
            setTimeout(() => {
                reiniciarScanner();
            }, 3000);
        }
        
    } catch (error) {
        console.error('Erro na fun√ß√£o buscarUsuario:', error);
        mostrarFeedback('Erro interno do sistema', 'error');
        setTimeout(() => {
            reiniciarScanner();
        }, 3000);
    }
}

// Mostrar feedback visual
function mostrarFeedback(mensagem, tipo) {
    // Remover feedback anterior se existir
    const feedbackExistente = document.getElementById('feedback-message');
    if (feedbackExistente) {
        feedbackExistente.remove();
    }
    
    const feedback = document.createElement('div');
    feedback.id = 'feedback-message';
    feedback.className = `fixed top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg text-white font-semibold z-50 ${
        tipo === 'success' ? 'bg-green-500' : 
        tipo === 'error' ? 'bg-red-500' : 
        'bg-blue-500'
    }`;
    feedback.textContent = mensagem;
    
    document.body.appendChild(feedback);
    
    // Remover ap√≥s 3 segundos
    setTimeout(() => {
        if (feedback.parentNode) {
            feedback.remove();
        }
    }, 3000);
}

// Redirecionar para tela de boas-vindas
function redirecionarParaBemVindo(nomeCompleto) {
    // Extrair primeiro nome
    const primeiroNome = nomeCompleto.split(' ')[0];
    
    // Salvar nome no localStorage para a pr√≥xima tela
    localStorage.setItem('usuarioNome', primeiroNome);
    
    // Redirecionar
    window.location.href = 'tela_depois_cracha.html';
}

// Reiniciar scanner
function reiniciarScanner() {
    if (isScanning) return;
    
    // Limpar scanner anterior
    try {
        Quagga.stop();
    } catch (e) {
        console.log('Scanner j√° estava parado');
    }
    
    setTimeout(() => {
        initBarcodeScanner();
    }, 1000);
}

// Fun√ß√£o para for√ßar reinicializa√ß√£o do scanner
let retryCount = 0;
const maxRetries = 3;

function forcarReinicializacaoScanner() {
    retryCount++;
    console.log(`Reinicializando scanner... (tentativa ${retryCount}/${maxRetries})`);
    
    // Parar scanner atual
    try {
        Quagga.stop();
    } catch (e) {
        console.log('Erro ao parar scanner:', e);
    }
    
    isScanning = false;
    
    if (retryCount < maxRetries) {
        // Reiniciar ap√≥s 5 segundos
        setTimeout(() => {
            console.log('Reiniciando scanner ap√≥s timeout...');
            initBarcodeScanner();
        }, 5000);
    } else {
        console.log('M√°ximo de tentativas atingido. Scanner desabilitado.');
        mostrarFeedback('Scanner temporariamente indispon√≠vel. Recarregue a p√°gina.', 'error');
    }
}

// Fun√ß√£o para limpar stream quando necess√°rio
function limparStream() {
    if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
    }
}

// Fun√ß√£o para reinicializar c√¢mera se necess√°rio
function reinicializarCamera() {
    limparStream();
    setTimeout(() => {
        initWebcam();
    }, 500);
}

// Mostrar indicador de qualidade
function mostrarIndicadorQualidade() {
    const indicator = document.getElementById('qualityIndicator');
    if (indicator) {
        indicator.classList.remove('hidden');
    }
}

// Atualizar indicador de qualidade
function atualizarIndicadorQualidade(texto) {
    const qualityText = document.getElementById('qualityText');
    if (qualityText) {
        qualityText.textContent = texto;
    }
}

// Ocultar indicador de qualidade
function ocultarIndicadorQualidade() {
    const indicator = document.getElementById('qualityIndicator');
    if (indicator) {
        indicator.classList.add('hidden');
    }
}

// Simplex Noise Implementation (simplified)
class SimplexNoise {
    constructor() {
        this.grad3 = [
            [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
            [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
            [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];
        this.p = [];
        for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(Math.random() * 256);
        }
        this.perm = [];
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
    }

    dot(g, x, y, z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }

    noise(xin, yin, zin) {
        const F3 = 1.0 / 3.0;
        const G3 = 1.0 / 6.0;
        
        const s = (xin + yin + zin) * F3;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const k = Math.floor(zin + s);
        
        const t = (i + j + k) * G3;
        const x0 = xin - i + t;
        const y0 = yin - j + t;
        const z0 = zin - k + t;
        
        let i1, j1, k1, i2, j2, k2;
        if (x0 >= y0) {
            if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
            else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
            else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
        } else {
            if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
            else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
            else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
        }
        
        const x1 = x0 - i1 + G3;
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3;
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3;
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;
        
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
        const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
        const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
        
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        let n0 = 0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
        }
        
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        let n1 = 0;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
        }
        
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        let n2 = 0;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
        }
        
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        let n3 = 0;
        if (t3 >= 0) {
            t3 *= t3;
            n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
        }
        
        return 32.0 * (n0 + n1 + n2 + n3);
    }
}

// Vortex Animation Class
class VortexAnimation {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.options = {
            particleCount: options.particleCount || 700,
            rangeY: options.rangeY || 100,
            baseHue: options.baseHue || 220,
            baseSpeed: options.baseSpeed || 0.0,
            rangeSpeed: options.rangeSpeed || 1.5,
            baseRadius: options.baseRadius || 1,
            rangeRadius: options.rangeRadius || 2,
            backgroundColor: options.backgroundColor || '#000000',
            ...options
        };
        
        this.particlePropCount = 9;
        this.particlePropsLength = this.options.particleCount * this.particlePropCount;
        this.baseTTL = 50;
        this.rangeTTL = 150;
        this.rangeHue = 100;
        this.noiseSteps = 3;
        this.xOff = 0.00125;
        this.yOff = 0.00125;
        this.zOff = 0.0005;
        
        this.tick = 0;
        this.noise3D = new SimplexNoise();
        this.particleProps = new Float32Array(this.particlePropsLength);
        this.center = [0, 0];
        
        this.HALF_PI = 0.5 * Math.PI;
        this.TAU = 2 * Math.PI;
        this.TO_RAD = Math.PI / 180;
        
        this.init();
    }

    init() {
        this.resize();
        this.initParticles();
        this.draw();
    }

    initParticles() {
        this.tick = 0;
        this.particleProps = new Float32Array(this.particlePropsLength);
        
        for (let i = 0; i < this.particlePropsLength; i += this.particlePropCount) {
            this.initParticle(i);
        }
    }

    initParticle(i) {
        const x = this.rand(this.canvas.width);
        const y = this.center[1] + this.randRange(this.options.rangeY);
        const vx = 0;
        const vy = 0;
        const life = 0;
        const ttl = this.baseTTL + this.rand(this.rangeTTL);
        const speed = this.options.baseSpeed + this.rand(this.options.rangeSpeed);
        const radius = this.options.baseRadius + this.rand(this.options.rangeRadius);
        const hue = this.options.baseHue + this.rand(this.rangeHue);

        this.particleProps.set([x, y, vx, vy, life, ttl, speed, radius, hue], i);
    }

    draw() {
        this.tick++;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.options.backgroundColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.drawParticles();
        this.renderGlow();
        this.renderToScreen();

        requestAnimationFrame(() => this.draw());
    }

    drawParticles() {
        for (let i = 0; i < this.particlePropsLength; i += this.particlePropCount) {
            this.updateParticle(i);
        }
    }

    updateParticle(i) {
        const i2 = 1 + i, i3 = 2 + i, i4 = 3 + i, i5 = 4 + i;
        const i6 = 5 + i, i7 = 6 + i, i8 = 7 + i, i9 = 8 + i;

        let x = this.particleProps[i];
        let y = this.particleProps[i2];
        const n = this.noise3D.noise(x * this.xOff, y * this.yOff, this.tick * this.zOff) * this.noiseSteps * this.TAU;
        const vx = this.lerp(this.particleProps[i3], Math.cos(n), 0.5);
        const vy = this.lerp(this.particleProps[i4], Math.sin(n), 0.5);
        let life = this.particleProps[i5];
        const ttl = this.particleProps[i6];
        const speed = this.particleProps[i7];
        const x2 = x + vx * speed;
        const y2 = y + vy * speed;
        const radius = this.particleProps[i8];
        const hue = this.particleProps[i9];

        this.drawParticle(x, y, x2, y2, life, ttl, radius, hue);

        life++;

        this.particleProps[i] = x2;
        this.particleProps[i2] = y2;
        this.particleProps[i3] = vx;
        this.particleProps[i4] = vy;
        this.particleProps[i5] = life;

        if (this.checkBounds(x, y) || life > ttl) {
            this.initParticle(i);
        }
    }

    drawParticle(x, y, x2, y2, life, ttl, radius, hue) {
        this.ctx.save();
        this.ctx.lineCap = 'round';
        this.ctx.lineWidth = radius;
        this.ctx.strokeStyle = `hsla(${hue},100%,60%,${this.fadeInOut(life, ttl)})`;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        this.ctx.closePath();
        this.ctx.restore();
    }

    checkBounds(x, y) {
        return x > this.canvas.width || x < 0 || y > this.canvas.height || y < 0;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.center[0] = 0.5 * this.canvas.width;
        this.center[1] = 0.5 * this.canvas.height;
    }

    renderGlow() {
        this.ctx.save();
        this.ctx.filter = 'blur(8px) brightness(200%)';
        this.ctx.globalCompositeOperation = 'lighter';
        this.ctx.drawImage(this.canvas, 0, 0);
        this.ctx.restore();

        this.ctx.save();
        this.ctx.filter = 'blur(4px) brightness(200%)';
        this.ctx.globalCompositeOperation = 'lighter';
        this.ctx.drawImage(this.canvas, 0, 0);
        this.ctx.restore();
    }

    renderToScreen() {
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'lighter';
        this.ctx.drawImage(this.canvas, 0, 0);
        this.ctx.restore();
    }

    // Utility functions
    rand(n) { return n * Math.random(); }
    randRange(n) { return n - this.rand(2 * n); }
    fadeInOut(t, m) {
        const hm = 0.5 * m;
        return Math.abs(((t + hm) % m) - hm) / hm;
    }
    lerp(n1, n2, speed) {
        return (1 - speed) * n1 + speed * n2;
    }
}

// Inicializar anima√ß√£o Vortex
let vortexAnimation = null;

function initVortexAnimation() {
    const canvas = document.getElementById('vortexCanvas');
    if (canvas) {
        vortexAnimation = new VortexAnimation(canvas, {
            particleCount: 500,
            rangeY: 800,
            baseHue: 120,
            baseSpeed: 0.0,
            rangeSpeed: 1.5,
            baseRadius: 1,
            rangeRadius: 2,
            backgroundColor: 'black'
        });
        
        // Redimensionar quando a janela mudar
        window.addEventListener('resize', () => {
            if (vortexAnimation) {
                vortexAnimation.resize();
            }
        });
    }
}

// Fun√ß√£o para fade-in suave da tela principal
function smoothFadeIn() {
    // Adicionar overlay inicial
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000000;
        z-index: 9999;
        opacity: 1;
        transition: opacity 1s ease-in-out;
    `;
    document.body.appendChild(overlay);
    
    // Fade out ap√≥s carregar
    setTimeout(() => {
        overlay.style.opacity = '0';
        setTimeout(() => {
            overlay.remove();
        }, 1000);
    }, 100);
}

// Inicializa a webcam quando a p√°gina carrega
document.addEventListener('DOMContentLoaded', () => {
    smoothFadeIn();
    initVortexAnimation();
    initWebcam();
});

// Limpa o stream quando a p√°gina √© fechada
window.addEventListener('beforeunload', () => {
    limparStream();
    
    if (isScanning) {
        Quagga.stop();
    }
});

// Person Detection Class for tela_principal
class PersonDetector {
    constructor() {
        this.video = null;
        this.model = null;
        this.isDetecting = false;
        this.lastPersonDetection = Date.now();
        this.noPersonTimeout = null;
        this.config = {
            minConfidence: 0.5,
            detectionInterval: 200, // 5 FPS
            noPersonTimeout: 10000 // 10 segundos
        };
    }

    async init() {
        try {
            // Carregar modelo COCO-SSD
            console.log('Carregando modelo para detec√ß√£o de pessoa...');
            this.model = await cocoSsd.load({
                base: 'mobilenet_v2',
                version: 'lite_mobilenet_v2'
            });
            
            console.log('Modelo carregado com sucesso');
            this.startDetection();
            
        } catch (error) {
            console.error('Erro ao carregar modelo:', error);
        }
    }

    startDetection() {
        if (!this.model) return;

        const detectPerson = async () => {
            if (this.video && this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                try {
                    const predictions = await this.model.detect(this.video);
                    const persons = predictions.filter(prediction => 
                        prediction.class === 'person' && 
                        prediction.score > this.config.minConfidence
                    );

                    if (persons.length > 0) {
                        console.log('Pessoa detectada na tela principal');
                        this.lastPersonDetection = Date.now();
                        this.clearNoPersonTimeout();
                    } else {
                        this.checkNoPersonTimeout();
                    }
                } catch (error) {
                    console.error('Erro na detec√ß√£o:', error);
                }
            }

            if (this.isDetecting) {
                setTimeout(detectPerson, this.config.detectionInterval);
            }
        };

        this.isDetecting = true;
        detectPerson();
    }

    checkNoPersonTimeout() {
        const timeSinceLastDetection = Date.now() - this.lastPersonDetection;
        
        if (timeSinceLastDetection >= this.config.noPersonTimeout) {
            console.log('Nenhuma pessoa detectada por 10 segundos - Voltando para tela de descanso');
            this.returnToIdleScreen();
        }
    }

    clearNoPersonTimeout() {
        if (this.noPersonTimeout) {
            clearTimeout(this.noPersonTimeout);
            this.noPersonTimeout = null;
        }
    }

    returnToIdleScreen() {
        this.isDetecting = false;
        if (this.video && this.video.srcObject) {
            this.video.srcObject.getTracks().forEach(track => track.stop());
        }
        // Voltar para tela de descanso
        window.location.href = 'index.html';
    }

    stop() {
        this.isDetecting = false;
        this.clearNoPersonTimeout();
    }
}

// Inicializar detec√ß√£o de pessoa quando a p√°gina carrega
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM carregado, inicializando sistema...');
    
    // Inicializar detec√ß√£o de pessoa
    const personDetector = new PersonDetector();
    personDetector.init();
    
    // Limpar recursos ao sair da p√°gina
    window.addEventListener('beforeunload', () => {
        personDetector.stop();
    });
});

</script>
</html>
