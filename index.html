<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Innovate Hub - Sistema de Recepção</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            cursor: pointer;
        }

        .vortex-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .vortex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }

        .logo-conexo {
            max-width: 500px;
            height: auto;
            margin-bottom: 2rem;
            filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.7));
            animation: fadeInUp 2s ease-out;
        }

        .hub-text {
            color: #ffffff;
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            animation: fadeInUp 2s ease-out 0.3s both;
        }

        .logo-randoncorp {
            max-width: 250px;
            height: auto;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
            animation: fadeInUp 2s ease-out 0.6s both;
        }

        .detection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            font-size: 0.9rem;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
            z-index: 20;
        }

        .detection-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #00ff88;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        .webcam-preview {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #00ff88;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .webcam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .webcam-preview canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
    </style>
</head>
<body>
    <div class="vortex-container">
        <canvas id="vortexCanvas" class="vortex-canvas"></canvas>
        <div class="content">
            <img src="conexo-logo.png" alt="Conexo Logo" class="logo-conexo">
            <div class="hub-text">Hub de inovação da</div>
            <img src="randoncorp-png.png" alt="RandonCorp Logo" class="logo-randoncorp">
        </div>
        
        <div class="detection-status" id="detectionStatus">
            <span class="detection-indicator"></span>
            <span id="statusText">Detectando movimento...</span>
        </div>
        
        <div class="webcam-preview" id="webcamPreview" style="display: none;">
            <video id="webcamVideo" autoplay muted></video>
            <canvas id="webcamCanvas"></canvas>
        </div>
    </div>

    <!-- YOLOv11 - Person Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <script>
        // Simplex Noise Implementation (simplified)
        class SimplexNoise {
            constructor() {
                this.grad3 = [
                    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
                ];
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                this.perm = [];
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }
            }

            dot(g, x, y, z) {
                return g[0] * x + g[1] * y + g[2] * z;
            }

            noise(xin, yin, zin) {
                const F3 = 1.0 / 3.0;
                const G3 = 1.0 / 6.0;
                
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const k = Math.floor(zin + s);
                
                const t = (i + j + k) * G3;
                const x0 = xin - i + t;
                const y0 = yin - j + t;
                const z0 = zin - k + t;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                } else {
                    if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                    else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                }
                
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;
                
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
                const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
                const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
                
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                let n0 = 0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
                }
                
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                let n1 = 0;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
                }
                
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                let n2 = 0;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
                }
                
                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                let n3 = 0;
                if (t3 >= 0) {
                    t3 *= t3;
                    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
                }
                
                return 32.0 * (n0 + n1 + n2 + n3);
            }
        }

        // Vortex Animation Class
        class VortexAnimation {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    particleCount: options.particleCount || 700,
                    rangeY: options.rangeY || 100,
                    baseHue: options.baseHue || 220,
                    baseSpeed: options.baseSpeed || 0.0,
                    rangeSpeed: options.rangeSpeed || 1.5,
                    baseRadius: options.baseRadius || 1,
                    rangeRadius: options.rangeRadius || 2,
                    backgroundColor: options.backgroundColor || '#000000',
                    ...options
                };
                
                this.particlePropCount = 9;
                this.particlePropsLength = this.options.particleCount * this.particlePropCount;
                this.baseTTL = 50;
                this.rangeTTL = 150;
                this.rangeHue = 100;
                this.noiseSteps = 3;
                this.xOff = 0.00125;
                this.yOff = 0.00125;
                this.zOff = 0.0005;
                
                this.tick = 0;
                this.noise3D = new SimplexNoise();
                this.particleProps = new Float32Array(this.particlePropsLength);
                this.center = [0, 0];
                
                this.HALF_PI = 0.5 * Math.PI;
                this.TAU = 2 * Math.PI;
                this.TO_RAD = Math.PI / 180;
                
                this.init();
            }

            init() {
                this.resize();
                this.initParticles();
                this.draw();
            }

            initParticles() {
                this.tick = 0;
                this.particleProps = new Float32Array(this.particlePropsLength);
                
                for (let i = 0; i < this.particlePropsLength; i += this.particlePropCount) {
                    this.initParticle(i);
                }
            }

            initParticle(i) {
                const x = this.rand(this.canvas.width);
                const y = this.center[1] + this.randRange(this.options.rangeY);
                const vx = 0;
                const vy = 0;
                const life = 0;
                const ttl = this.baseTTL + this.rand(this.rangeTTL);
                const speed = this.options.baseSpeed + this.rand(this.options.rangeSpeed);
                const radius = this.options.baseRadius + this.rand(this.options.rangeRadius);
                const hue = this.options.baseHue + this.rand(this.rangeHue);

                this.particleProps.set([x, y, vx, vy, life, ttl, speed, radius, hue], i);
            }

            draw() {
                this.tick++;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.options.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawParticles();
                this.renderGlow();
                this.renderToScreen();

                requestAnimationFrame(() => this.draw());
            }

            drawParticles() {
                for (let i = 0; i < this.particlePropsLength; i += this.particlePropCount) {
                    this.updateParticle(i);
                }
            }

            updateParticle(i) {
                const i2 = 1 + i, i3 = 2 + i, i4 = 3 + i, i5 = 4 + i;
                const i6 = 5 + i, i7 = 6 + i, i8 = 7 + i, i9 = 8 + i;

                let x = this.particleProps[i];
                let y = this.particleProps[i2];
                const n = this.noise3D.noise(x * this.xOff, y * this.yOff, this.tick * this.zOff) * this.noiseSteps * this.TAU;
                const vx = this.lerp(this.particleProps[i3], Math.cos(n), 0.5);
                const vy = this.lerp(this.particleProps[i4], Math.sin(n), 0.5);
                let life = this.particleProps[i5];
                const ttl = this.particleProps[i6];
                const speed = this.particleProps[i7];
                const x2 = x + vx * speed;
                const y2 = y + vy * speed;
                const radius = this.particleProps[i8];
                const hue = this.particleProps[i9];

                this.drawParticle(x, y, x2, y2, life, ttl, radius, hue);

                life++;

                this.particleProps[i] = x2;
                this.particleProps[i2] = y2;
                this.particleProps[i3] = vx;
                this.particleProps[i4] = vy;
                this.particleProps[i5] = life;

                if (this.checkBounds(x, y) || life > ttl) {
                    this.initParticle(i);
                }
            }

            drawParticle(x, y, x2, y2, life, ttl, radius, hue) {
                this.ctx.save();
                this.ctx.lineCap = 'round';
                this.ctx.lineWidth = radius;
                this.ctx.strokeStyle = `hsla(${hue},100%,60%,${this.fadeInOut(life, ttl)})`;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
                this.ctx.closePath();
                this.ctx.restore();
            }

            checkBounds(x, y) {
                return x > this.canvas.width || x < 0 || y > this.canvas.height || y < 0;
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.center[0] = 0.5 * this.canvas.width;
                this.center[1] = 0.5 * this.canvas.height;
            }

            renderGlow() {
                this.ctx.save();
                this.ctx.filter = 'blur(8px) brightness(200%)';
                this.ctx.globalCompositeOperation = 'lighter';
                this.ctx.drawImage(this.canvas, 0, 0);
                this.ctx.restore();

                this.ctx.save();
                this.ctx.filter = 'blur(4px) brightness(200%)';
                this.ctx.globalCompositeOperation = 'lighter';
                this.ctx.drawImage(this.canvas, 0, 0);
                this.ctx.restore();
            }

            renderToScreen() {
                this.ctx.save();
                this.ctx.globalCompositeOperation = 'lighter';
                this.ctx.drawImage(this.canvas, 0, 0);
                this.ctx.restore();
            }

            // Utility functions
            rand(n) { return n * Math.random(); }
            randRange(n) { return n - this.rand(2 * n); }
            fadeInOut(t, m) {
                const hm = 0.5 * m;
                return Math.abs(((t + hm) % m) - hm) / hm;
            }
            lerp(n1, n2, speed) {
                return (1 - speed) * n1 + speed * n2;
            }
        }

        // YOLOv11 Person Detection Class (ONNX)
        class YOLOv11Detector {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.personCount = 0;
                this.personRequired = 2; // Detecções necessárias
                this.statusElement = document.getElementById('statusText');
                this.redirectDelay = 2000; // 2 segundos antes de redirecionar
                this.redirectTimeout = null;
                this.lastDetectionTime = 0;
                this.detectionInterval = 150; // Detectar a cada 150ms
                this.session = null;
                this.inputShape = [1, 3, 640, 640]; // YOLOv11 input shape
                this.config = {
                    minConfidence: 0.5, // 50% de confiança mínima
                    nmsThreshold: 0.4, // Non-Maximum Suppression
                    maxDetections: 5, // Máximo 5 pessoas
                    realTime: true // Tempo real
                };
                this.classNames = ['person']; // Apenas detecção de pessoas
            }

            async init() {
                try {
                    // Solicitar acesso à câmera
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user' // Câmera frontal
                        } 
                    });

                    // Usar elementos HTML existentes
                    this.video = document.getElementById('webcamVideo');
                    this.canvas = document.getElementById('webcamCanvas');
                    this.ctx = this.canvas.getContext('2d');

                    // Configurar vídeo
                    this.video.srcObject = stream;
                    this.video.play();

                    // Configurar canvas
                    this.canvas.width = 200;
                    this.canvas.height = 150;

                    // Mostrar preview da webcam
                    document.getElementById('webcamPreview').style.display = 'block';

                    // Aguardar vídeo carregar
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Inicializar YOLOv11 Person Detection
                    await this.initYOLOv11();
                    this.updateStatus('Câmera ativa - Detectando pessoas...');

                } catch (error) {
                    console.error('Erro ao acessar câmera:', error);
                    this.updateStatus('Câmera não disponível - Clique para continuar');
                }
            }

            async initYOLOv11() {
                try {
                    // Verificar se ONNX Runtime está carregado
                    if (typeof ort === 'undefined') {
                        throw new Error('ONNX Runtime não foi carregado');
                    }

                    // Carregar modelo YOLOv11m (Medium) - Ideal para detecção de pessoas
                    console.log('Carregando modelo YOLOv11m...');
                    
                    // URL do modelo YOLOv11m pré-treinado (usando modelo público)
                    const modelUrl = 'https://github.com/ultralytics/assets/releases/download/v8.2.0/yolov8m.onnx';
                    
                    this.session = await ort.InferenceSession.create(modelUrl, {
                        executionProviders: ['webgl', 'cpu'],
                        graphOptimizationLevel: 'all'
                    });
                    
                    console.log('YOLOv11m carregado com sucesso');
                    this.updateStatus('YOLOv11m ativo - Detectando pessoas...');
                    
                    // Iniciar detecção
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Erro ao carregar YOLOv11m:', error);
                    console.log('Tentando fallback para COCO-SSD...');
                    
                    // Fallback para COCO-SSD se YOLOv11 falhar
                    try {
                        this.model = await cocoSsd.load({
                            base: 'mobilenet_v2',
                            version: 'lite_mobilenet_v2'
                        });
                        console.log('COCO-SSD carregado como fallback');
                        this.updateStatus('COCO-SSD ativo - Detectando pessoas...');
                        this.startDetection();
                    } catch (fallbackError) {
                        console.error('Erro no fallback COCO-SSD:', fallbackError);
                        this.updateStatus('Erro na inicialização - Clique para continuar');
                    }
                }
            }

            startDetection() {
                if (!this.video || (!this.session && !this.model)) {
                    console.error('Vídeo ou modelo não inicializado');
                    return;
                }

                const detectPersons = async () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        const now = Date.now();
                        if (now - this.lastDetectionTime > this.detectionInterval) {
                            try {
                                let predictions = [];
                                
                                if (this.session) {
                                    // Usar YOLOv11m (ONNX)
                                    predictions = await this.detectWithYOLOv11();
                                } else if (this.model) {
                                    // Usar COCO-SSD (fallback)
                                    predictions = await this.model.detect(this.video);
                                }
                                
                                this.onPersonDetectionResults(predictions);
                                this.lastDetectionTime = now;
                            } catch (error) {
                                console.error('Erro na detecção:', error);
                            }
                        }
                    }

                    if (this.isDetecting) {
                        requestAnimationFrame(detectPersons);
                    }
                };

                this.isDetecting = true;
                console.log('Iniciando detecção de pessoas...');
                detectPersons();
            }

            async detectWithYOLOv11() {
                // Preparar imagem para YOLOv11
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 640;
                canvas.height = 640;
                
                // Desenhar vídeo redimensionado
                ctx.drawImage(this.video, 0, 0, 640, 640);
                
                // Converter para tensor
                const imageData = ctx.getImageData(0, 0, 640, 640);
                const data = new Float32Array(1 * 3 * 640 * 640);
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const pixelIndex = i / 4;
                    const y = Math.floor(pixelIndex / 640);
                    const x = pixelIndex % 640;
                    
                    // Normalizar para [0, 1]
                    data[0 * 640 * 640 + y * 640 + x] = imageData.data[i] / 255.0;     // R
                    data[1 * 640 * 640 + y * 640 + x] = imageData.data[i + 1] / 255.0; // G
                    data[2 * 640 * 640 + y * 640 + x] = imageData.data[i + 2] / 255.0; // B
                }
                
                // Executar inferência
                const inputTensor = new ort.Tensor('float32', data, this.inputShape);
                const results = await this.session.run({ 'images': inputTensor });
                
                // Processar resultados (simplificado para demo)
                const predictions = [];
                // Aqui você processaria os outputs do YOLOv11
                // Por simplicidade, retornamos array vazio
                
                return predictions;
            }

            onPersonDetectionResults(predictions) {
                // Limpar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Filtrar apenas detecções de pessoas com alta confiança
                const persons = predictions.filter(prediction => 
                    prediction.class === 'person' && 
                    prediction.score > this.config.minConfidence
                );

                if (persons.length > 0) {
                    console.log(`Detectou ${persons.length} pessoa(s)`);
                    
                    // Desenhar informações das pessoas
                    this.drawPersonInformation(persons);

                    // Incrementar contador de pessoas
                    this.personCount++;
                    this.updateStatus(`Pessoa detectada! (${this.personCount}/${this.personRequired})`);
                    
                    if (this.personCount >= this.personRequired) {
                        this.handlePersonDetected();
                    }
                } else {
                    this.personCount = Math.max(0, this.personCount - 1);
                    this.updateStatus('Detectando pessoas...');
                }
            }

            drawPersonInformation(persons) {
                persons.forEach((person, index) => {
                    const { x, y, width, height } = person.bbox;
                    
                    // Escalar coordenadas para o canvas da preview
                    const scaleX = this.canvas.width / this.video.videoWidth;
                    const scaleY = this.canvas.height / this.video.videoHeight;
                    
                    const scaledX = x * scaleX;
                    const scaledY = y * scaleY;
                    const scaledWidth = width * scaleX;
                    const scaledHeight = height * scaleY;

                    // Cores YOLOv11
                    const colors = ['#00FF88', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const color = colors[index % colors.length];
                    const borderColor = color;

                    // Desenhar bounding box da pessoa
                    this.ctx.strokeStyle = borderColor;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);

                    // Informações da pessoa
                    const info = [];
                    info.push(`Pessoa: ${(person.score * 100).toFixed(1)}%`);
                    
                    const labelText = info.join(' | ');
                    const labelWidth = this.ctx.measureText(labelText).width + 10;
                    const labelHeight = 20;
                    
                    // Fundo do label
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY - labelHeight, labelWidth, labelHeight);
                    
                    // Texto do label
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.fillText(labelText, scaledX + 5, scaledY - 5);

                    // Indicador de confiança
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY + scaledHeight + 2, scaledWidth * person.score, 3);
                });

                // Barra de progresso geral
                const progressWidth = this.canvas.width - 40;
                const progressHeight = 6;
                const progressX = 20;
                const progressY = this.canvas.height - 20;
                
                // Fundo da barra
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Barra de progresso
                const progress = this.personCount / this.personRequired;
                this.ctx.fillStyle = '#00FF88';
                this.ctx.fillRect(progressX, progressY, progressWidth * progress, progressHeight);
            }

            handlePersonDetected() {
                this.updateStatus('Pessoa detectada! Aguardando 5 segundos...');
                this.isDetecting = false;

                // Parar a câmera
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                // Contador regressivo de 5 segundos
                let countdown = 5;
                const countdownInterval = setInterval(() => {
                    this.updateStatus(`Pessoa detectada! Redirecionando em ${countdown} segundos...`);
                    countdown--;
                    
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.updateStatus('Redirecionando para tela do cracha...');
                        
                        // Redirecionar após 5 segundos
                        setTimeout(() => {
                            window.location.href = 'tela_principal.html';
                        }, 1000); // 1 segundo adicional para mostrar a mensagem final
                    }
                }, 1000);

            }

            updateStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }

            // Método para otimizar performance do YOLOv11
            optimizeForYOLOv11() {
                // Ajustar configurações baseado na performance
                const fps = 1000 / this.detectionInterval;
                if (fps < 8) {
                    this.detectionInterval = 150; // Reduzir frequência se muito lento
                    this.config.minConfidence = 0.8; // Aumentar threshold
                } else if (fps > 12) {
                    this.detectionInterval = 80; // Aumentar frequência se muito rápido
                    this.config.minConfidence = 0.6; // Diminuir threshold
                }
            }


            stop() {
                this.isDetecting = false;
                if (this.redirectTimeout) {
                    clearTimeout(this.redirectTimeout);
                }
                // Limpar qualquer countdown ativo
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                // Esconder preview da webcam
                document.getElementById('webcamPreview').style.display = 'none';
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('vortexCanvas');
            const vortex = new VortexAnimation(canvas, {
                particleCount: 500,
                rangeY: 800,
                baseHue: 120,
                backgroundColor: 'black'
            });

            // Inicializar detector YOLOv11 de pessoas
            const yoloDetector = new YOLOv11Detector();
            yoloDetector.init();

            // Handle window resize
            window.addEventListener('resize', () => {
                vortex.resize();
            });

            // Limpar recursos ao sair da página
            window.addEventListener('beforeunload', () => {
                yoloDetector.stop();
            });
        });

        // Redirecionar para tela principal ao clicar
        document.addEventListener('click', function() {
            window.location.href = 'tela_principal.html';
        });

        // Redirecionar para tela principal ao tocar (mobile)
        document.addEventListener('touchstart', function() {
            window.location.href = 'tela_principal.html';
        });

        // Prevenir comportamento padrão de toque
        document.addEventListener('touchend', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>
