<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Innovate Hub - Sistema de Recepção</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            cursor: pointer;
        }

        .vortex-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .vortex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }

         .logo-conexo {
             max-width: 500px;
             height: auto;
             margin-bottom: 2rem;
             filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.7));
             animation: fadeInUp 2s ease-out;
         }

        .hub-text {
            color: #ffffff;
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            margin-top: 12rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            animation: fadeInUp 2s ease-out 0.3s both;
        }

        .logo-randoncorp {
            max-width: 250px;
            height: auto;
            margin-top: 0.5rem;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
            animation: fadeInUp 2s ease-out 0.6s both;
        }


        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        /* Estilos da Tela de Scanner */
        .scanner-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s ease-in-out;
        }

        .scanner-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        .scanner-container {
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .scanner-icon {
            margin-bottom: 2rem;
        }

        .scanner-icon .material-symbols-outlined {
            font-size: 100px;
            color: #39E079;
        }

        .scanner-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #00f0ff, #7f00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .scanner-subtitle {
            font-size: 1.125rem;
            color: #8888a0;
            margin-bottom: 3rem;
        }


        .scanner-help {
            font-size: 0.875rem;
            color: #8888a0;
        }

        /* Face Detection Styles */
        .face-detection-container {
            position: relative;
            width: 320px;
            height: 400px;
            margin: 2rem auto;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 192, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 192, 0.2);
        }

        .face-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .face-outline {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 250px;
            border: 3px solid #00FFC0;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 194, 0.5);
            pointer-events: none;
            animation: facePulse 2s infinite;
        }

        .face-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
        }

        .detection-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: #00FFC0;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .detection-status .material-symbols-outlined {
            font-size: 2rem;
            animation: searchPulse 1.5s infinite;
        }

        @keyframes facePulse {
            0%, 100% { 
                border-color: #00FFC0;
                box-shadow: 0 0 20px rgba(0, 255, 194, 0.5);
            }
            50% { 
                border-color: #00FF80;
                box-shadow: 0 0 30px rgba(0, 255, 194, 0.8);
            }
        }

        @keyframes searchPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.7;
            }
        }



        @keyframes scanLine {
            0% { transform: translateY(0px); opacity: 1; }
            50% { transform: translateY(192px); opacity: 1; }
            100% { transform: translateY(0px); opacity: 1; }
        }

        @keyframes holographic-pulse {
            0% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
            50% { box-shadow: 0 0 20px #7f00ff, 0 0 40px #7f00ff, inset 0 0 20px #7f00ff; }
            100% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
        }
    </style>
</head>
<body>
    <div class="vortex-container">
        <canvas id="vortexCanvas" class="vortex-canvas"></canvas>
                <!-- Tela de Descanso -->
                <div class="content" id="idleScreen">
                    <img src="conexo-logo.png" alt="Conexo Logo" class="logo-conexo">
                    <div class="hub-text">Hub de inovação da</div>
                    <img src="randoncorp-png.png" alt="RandonCorp Logo" class="logo-randoncorp">
                </div>

        <!-- Tela de Reconhecimento Facial -->
        <div class="scanner-content" id="scannerScreen" style="display: none;">
            <div class="scanner-container">
                <div class="scanner-icon">
                    <span class="material-symbols-outlined">face</span>
                </div>
                <h1 class="scanner-title">Reconhecimento Facial</h1>
                <p class="scanner-subtitle">Posicione seu rosto na área demarcada</p>
                
                <div class="face-detection-container">
                    <div class="face-outline"></div>
                    <video id="faceVideo" class="face-video" autoplay muted playsinline></video>
                    <div class="face-overlay">
                        <div class="detection-status" id="detectionStatus">
                            <span class="material-symbols-outlined">search</span>
                            <span>Detectando rosto...</span>
                        </div>
                        
                        <div class="mt-4 text-center">
                            <button id="restartButton" onclick="restartFacialRecognition()" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded opacity-0 transition-opacity duration-300">
                                <span class="material-symbols-outlined mr-2">refresh</span>
                                Reiniciar Detecção
                            </button>
                        </div>
                    </div>
                </div>
                
                <p class="scanner-help">Sistema de reconhecimento facial ativo.</p>
            </div>
        </div>
        
    </div>

    <!-- Dependências -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <script src="supabase_config.js"></script>

    <script>
        // Inicializar Supabase globalmente (apenas uma instância)
        if (!window.supabaseClient) {
            const supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
            const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
            window.supabaseClient = window.supabase.createClient(supabaseUrl, supabaseKey);
        }
        
        // Inicializar SupabaseManager (apenas uma instância)
        if (!window.supabaseManager) {
            window.supabaseManager = new SupabaseManager();
        }

        // Sistema de Reconhecimento Facial com CompreFace
        class CompreFaceDetector {
            constructor() {
                this.apiKey = 'c3e84a46-1a08-4913-8330-31818f0c0e06';
                this.baseUrl = 'http://localhost:8000/api/v1'; // URL local do CompreFace
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.detectionInterval = null;
                this.faceDetected = false;
                this.recognitionThreshold = 0.6;
                this.useSimulatedMode = false;
                this.subjectId = null; // ID do usuário reconhecido
            }

            async init() {
                try {
                    console.log('🎭 Inicializando sistema de reconhecimento facial...');
                    
                    // Verificar se CompreFace está disponível
                    const isCompreFaceAvailable = await this.checkCompreFaceStatus();
                    
                    if (!isCompreFaceAvailable) {
                        console.log('⚠️ CompreFace não disponível, usando modo simulado');
                        this.useSimulatedMode = true;
                        this.updateStatus('Modo simulado ativo - CompreFace não disponível', 'info');
                    }
                    
                    // Configurar câmera
                    await this.setupCamera();
                    
                    // Iniciar detecção
                    this.startDetection();
                    
                    console.log('✅ Sistema de reconhecimento facial inicializado');
                } catch (error) {
                    console.error('❌ Erro ao inicializar sistema:', error);
                    this.showError('Sistema de reconhecimento facial indisponível');
                }
            }

            async checkCompreFaceStatus() {
                try {
                    // CompreFace não tem endpoint /status, vamos testar com /faces
                    const response = await fetch(`${this.baseUrl}/api/v1/applications`, {
                        method: 'GET',
                        headers: {
                            'x-api-key': this.apiKey
                        },
                        timeout: 5000 // 5 segundos de timeout
                    });
                    
                    if (response.ok) {
                        console.log('✅ CompreFace está online e configurado');
                        return true;
                    } else if (response.status === 400) {
                        // Status 400 pode significar que não há faces cadastradas, mas a API está funcionando
                        console.log('✅ CompreFace está online (sem faces cadastradas)');
                        return true;
                    } else {
                        throw new Error(`CompreFace não disponível: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('⚠️ CompreFace não está disponível:', error.message);
                    return false;
                }
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });

                    this.video = document.getElementById('faceVideo');
                    this.video.srcObject = stream;
                    
                    // Aguardar vídeo carregar
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error(`Erro ao acessar câmera: ${error.message}`);
                }
            }

            startDetection() {
                if (this.isDetecting) return;
                
                this.isDetecting = true;
                console.log('🔍 Iniciando detecção facial...');
                
                // Detectar faces a cada 2 segundos
                this.detectionInterval = setInterval(() => {
                    this.detectFaces();
                }, 2000);
            }

            async detectFaces() {
                try {
                    if (this.useSimulatedMode) {
                        // Modo simulado - simular detecção de rosto
                        this.simulateFaceDetection();
                        return;
                    }

                    // Capturar frame do vídeo
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Converter para base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    const base64Data = imageData.split(',')[1];
                    
                    // Enviar para CompreFace - Detecção de faces
                    const response = await fetch(`${this.baseUrl}/faces/detect`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey
                        },
                        body: JSON.stringify({
                            file: base64Data
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Erro na detecção: ${response.status}`);
                    }

                    const result = await response.json();
                    this.processDetectionResult(result);
                    
                } catch (error) {
                    console.error('Erro na detecção facial:', error);
                    // Se falhar, tentar modo simulado
                    if (!this.useSimulatedMode) {
                        console.log('🔄 Tentando modo simulado...');
                        this.useSimulatedMode = true;
                        this.simulateFaceDetection();
                    }
                }
            }

            simulateFaceDetection() {
                // Simular detecção de rosto após alguns segundos
                const randomDelay = Math.random() * 3000 + 2000; // 2-5 segundos
                
                setTimeout(async () => {
                    if (this.isDetecting) {
                        console.log('🎭 Simulando detecção de rosto...');
                        
                        // Usar o usuário real "Lucas Brasil Lima" para simulação
                        const usuarioSimulado = { nome_completo: 'Lucas Brasil Lima', matricula: '55942', empresa: 'Conexo', cargo: 'Assistente Administrativo' };
                        this.subjectId = usuarioSimulado.nome_completo;
                        
                        // Simular resultado de reconhecimento
                        this.processRecognitionResult({
                            result: [{
                                subjects: [{
                                    subject: usuarioSimulado.nome_completo,
                                    similarity: 0.85
                                }]
                            }]
                        });
                    }
                }, randomDelay);
            }

            processDetectionResult(result) {
                if (result.result && result.result.length > 0) {
                    console.log('👤 Rosto detectado!');
                    this.faceDetected = true;
                    this.updateStatus('Rosto detectado! Reconhecendo...', 'success');
                    
                    // Parar detecção e iniciar reconhecimento
                    this.stopDetection();
                    this.recognizeFace(result.result[0]);
                } else {
                    this.updateStatus('Posicione seu rosto na área demarcada', 'info');
                }
            }

            async recognizeFace(faceData) {
                try {
                    console.log('🔍 Iniciando reconhecimento...');
                    this.updateStatus('Reconhecendo identidade...', 'processing');
                    
                    if (this.useSimulatedMode) {
                        // Modo simulado - simular reconhecimento
                        setTimeout(async () => {
                            const isRecognized = Math.random() > 0.3; // 70% de chance de reconhecer
                            if (isRecognized) {
                                // Simular usuário reconhecido
                                const usuarioSimulado = {
                                    id: 'simulated_user_001',
                                    nome_completo: 'Usuário Teste',
                                    matricula: '12345',
                                    empresa: 'RandonCorp',
                                    cargo: 'Desenvolvedor'
                                };
                                
                                // Registrar acesso no Supabase
                                await this.registrarAcessoUsuario(usuarioSimulado, 'facial', 'sucesso', 0.85);
                                
                                this.handleRecognitionResult(true, `Bem-vindo, ${usuarioSimulado.nome_completo}!`);
                            } else {
                                this.handleRecognitionResult(false, 'Usuário não reconhecido (Simulado)');
                            }
                        }, 2000);
                    } else {
                        // Modo real com CompreFace - Reconhecimento facial
                        await this.performRealRecognition(faceData);
                    }
                    
                } catch (error) {
                    console.error('Erro no reconhecimento:', error);
                    this.handleRecognitionResult(false, 'Erro no reconhecimento');
                }
            }

            async performRealRecognition(faceData) {
                try {
                    // Capturar frame do vídeo para reconhecimento
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Converter para base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    const base64Data = imageData.split(',')[1];
                    
                    // Enviar para CompreFace - Reconhecimento
                    const response = await fetch(`${this.baseUrl}/faces/recognize`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey
                        },
                        body: JSON.stringify({
                            file: base64Data
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Erro no reconhecimento: ${response.status}`);
                    }

                    const result = await response.json();
                    this.processRecognitionResult(result);
                    
                } catch (error) {
                    console.error('Erro no reconhecimento real:', error);
                    this.handleRecognitionResult(false, 'Erro no reconhecimento');
                }
            }

            processRecognitionResult(result) {
                console.log('🎯 Resultado do reconhecimento:', result);
                
                if (result.result && result.result.length > 0) {
                    const recognition = result.result[0];
                    
                    // CompreFace retorna subjects com similarity
                    if (recognition.subjects && recognition.subjects.length > 0) {
                        const subject = recognition.subjects[0];
                        const similarity = subject.similarity || 0;
                        const subjectName = subject.subject;
                        
                        console.log(`👤 Usuário reconhecido: ${subjectName} (similaridade: ${similarity})`);
                        
                        if (similarity >= this.recognitionThreshold) {
                            // Usuário reconhecido com sucesso
                            this.subjectId = subjectName;
                            this.handleRecognitionResult(true, `Usuário reconhecido: ${subjectName}`);
                        } else {
                            // Similaridade muito baixa
                            this.handleRecognitionResult(false, 'Similaridade muito baixa no reconhecimento');
                        }
                    } else {
                        // Nenhum usuário reconhecido
                        this.handleRecognitionResult(false, 'Usuário não encontrado no banco de dados');
                    }
                } else {
                    // Nenhum resultado
                    this.handleRecognitionResult(false, 'Nenhum rosto detectado');
                }
            }

            // Registrar acesso do usuário no Supabase
            async registrarAcessoUsuario(usuario, tipoAcesso, status, confianca) {
                try {
                    if (window.supabaseManager) {
                        await window.supabaseManager.registrarAcesso(
                            usuario.id,
                            tipoAcesso,
                            status,
                            confianca,
                            null,
                            null,
                            this.useSimulatedMode ? 'Modo simulado ativo' : 'Reconhecimento facial real'
                        );
                        
                        // Atualizar último acesso
                        await window.supabaseManager.atualizarUltimoAcesso(usuario.id);
                        
                        console.log('✅ Acesso registrado no Supabase');
                    }
                } catch (error) {
                    console.error('Erro ao registrar acesso:', error);
                }
            }

            async handleRecognitionResult(success, message) {
                // Parar detecção imediatamente
                this.stopDetection();
                
                if (success) {
                    console.log('✅ Reconhecimento bem-sucedido!');
                    this.updateStatus('Verificando usuário...', 'processing');
                    
                    // Buscar dados do usuário no Supabase pelo nome
                    if (this.subjectId && window.supabaseManager) {
                        try {
                            // Buscar usuário pelo nome (que é o subject no CompreFace)
                            const usuario = await window.supabaseManager.buscarUsuarioPorNome(this.subjectId);
                            if (usuario) {
                                console.log('👤 Usuário encontrado:', usuario);
                                
                                // Registrar acesso no Supabase
                                await this.registrarAcessoUsuario(usuario, 'facial', 'sucesso', 0.9);
                                
                                // Atualizar título da tela com nome do usuário
                                this.updateTitle(`Bem-vindo, ${usuario.nome_completo}!`);
                                
                                // Redirecionar após 3 segundos
                                setTimeout(() => {
                                    this.redirectToWelcome(usuario);
                                }, 3000);
                            } else {
                                console.log('⚠️ Usuário não encontrado no banco de dados');
                                this.updateStatus('Usuário não cadastrado no sistema', 'error');
                                
                                // Mostrar botão de reiniciar
                                this.showRestartButton();
                                console.log('🛑 Sistema pausado - aguardando ação do usuário');
                            }
                        } catch (error) {
                            console.error('Erro ao buscar usuário:', error);
                            this.updateStatus('Erro ao verificar usuário', 'error');
                        }
                    } else {
                        // Redirecionar sem dados do usuário
                        setTimeout(() => {
                            this.redirectToWelcome();
                        }, 2000);
                    }
                } else {
                    console.log('❌ Reconhecimento falhou');
                    this.updateStatus('Acesso negado. Tente novamente.', 'error');
                    
                    // Mostrar botão de reiniciar
                    this.showRestartButton();
                    console.log('🛑 Sistema pausado - aguardando ação do usuário');
                }
            }

            updateStatus(message, type) {
                const statusElement = document.getElementById('detectionStatus');
                if (statusElement) {
                    const icon = statusElement.querySelector('.material-symbols-outlined');
                    const text = statusElement.querySelector('span:last-child');
                    
                    // Atualizar ícone baseado no tipo
                    switch (type) {
                        case 'success':
                            icon.textContent = 'check_circle';
                            statusElement.style.color = '#00FF80';
                            break;
                        case 'error':
                            icon.textContent = 'error';
                            statusElement.style.color = '#FF4444';
                            break;
                        case 'processing':
                            icon.textContent = 'sync';
                            statusElement.style.color = '#FFA500';
                            break;
                        default:
                            icon.textContent = 'search';
                            statusElement.style.color = '#00FFC0';
                    }
                    
                    text.textContent = message;
                }
            }

            updateTitle(message) {
                const titleElement = document.querySelector('.scanner-title');
                if (titleElement) {
                    titleElement.textContent = message;
                    titleElement.style.color = '#00FF80';
                    titleElement.style.fontSize = '2.5rem';
                    titleElement.style.fontWeight = 'bold';
                    titleElement.style.textShadow = '0 0 20px rgba(0, 255, 128, 0.8)';
                }
            }

            showRestartButton() {
                const restartButton = document.getElementById('restartButton');
                if (restartButton) {
                    restartButton.style.opacity = '1';
                }
            }

            hideRestartButton() {
                const restartButton = document.getElementById('restartButton');
                if (restartButton) {
                    restartButton.style.opacity = '0';
                }
            }

            redirectToWelcome(usuario = null) {
                // Implementar redirecionamento ou próxima ação
                console.log('🚀 Redirecionando para tela de boas-vindas...');
                
                if (usuario) {
                    console.log(`👋 Bem-vindo, ${usuario.nome_completo}!`);
                    console.log(`📋 Matrícula: ${usuario.matricula}`);
                    console.log(`🏢 Empresa: ${usuario.empresa}`);
                    console.log(`💼 Cargo: ${usuario.cargo}`);
                    
                    // Salvar dados do usuário no localStorage
                    localStorage.setItem('usuarioAtual', JSON.stringify(usuario));
                    localStorage.setItem('ultimoAcesso', new Date().toISOString());
                }
                
                // Aqui você pode redirecionar para outra página ou executar ação
                // Por exemplo: window.location.href = 'tela_boas_vindas.html';
            }

            showError(message) {
                this.updateStatus(message, 'error');
            }

            stopDetection() {
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                    this.detectionInterval = null;
                }
                this.isDetecting = false;
            }

            stop() {
                this.stopDetection();
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
            }
        }

        // Sistema de Reconhecimento de Voz - REMOVIDO
        /*
        class VoiceRecognitionSystem {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.attempts = 0;
                this.maxAttempts = 2;
                this.currentLanguage = 'pt-BR';
                this.languages = ['pt-BR', 'en-US', 'es-ES'];
                
                // Sistema de escalonamento de alertas
                this.alertHistory = [];
                this.alertThreshold = 3; // 3 confusões em 5 minutos
                this.alertWindow = 5 * 60 * 1000; // 5 minutos em ms
                this.highPriorityThreshold = 5; // 5 confusões = prioridade alta
                
                // Sistema de captura de áudio
                this.audioBuffer = [];
                this.audioBufferSize = 5; // 5 segundos
                this.audioSampleRate = 44100;
                this.audioChannels = 1;
                this.audioContext = null;
                this.audioWorklet = null;
                this.isRecording = false;
                this.confusionPatterns = {
                    'pt-BR': [
                        'o que é isso', 'não entendi', 'como funciona', 'o que fazer',
                        'não sei', 'como usar', 'o que devo falar', 'não compreendi',
                        'o que é', 'como é que funciona', 'não entendi nada', 'não saquei',
                        'não compreendi nada', 'o que devo fazer', 'como é que usa',
                        'não entendi como', 'o que é para fazer', 'como funciona isso',
                        'não sei o que fazer', 'o que é isso aqui', 'como é que é',
                        'não entendi nada disso', 'o que é para falar', 'como usar isso',
                        'não sei como funciona', 'o que é para dizer', 'como é que funciona isso'
                    ],
                    'en-US': [
                        'what is this', 'i don\'t understand', 'how does it work', 'what to do',
                        'i don\'t know', 'how to use', 'what should i say', 'i don\'t get it',
                        'what is', 'how does this work', 'i don\'t understand anything',
                        'what is this for', 'how do i use this', 'what am i supposed to do',
                        'i don\'t get how', 'what is this thing', 'how does this thing work',
                        'i don\'t know what to do', 'what is this here', 'how is this',
                        'i don\'t understand any of this', 'what am i supposed to say',
                        'how do i use this thing', 'i don\'t know how this works',
                        'what am i supposed to tell', 'how does this thing work'
                    ],
                    'es-ES': [
                        'qué es esto', 'no entiendo', 'cómo funciona', 'qué hacer',
                        'no sé', 'cómo usar', 'qué debo decir', 'no comprendo',
                        'qué es', 'cómo funciona esto', 'no entiendo nada', 'no capto',
                        'no comprendo nada', 'qué debo hacer', 'cómo es que se usa',
                        'no entiendo cómo', 'qué es para hacer', 'cómo funciona esto',
                        'no sé qué hacer', 'qué es esto aquí', 'cómo es que es',
                        'no entiendo nada de esto', 'qué es para hablar', 'cómo usar esto',
                        'no sé cómo funciona', 'qué es para decir', 'cómo es que funciona esto'
                    ]
                };
                this.matriculaPatterns = {
                    'pt-BR': [
                        /(?:minha matrícula é|matrícula|matricula|meu número é|número)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'en-US': [
                        /(?:my id is|id number|student id|my number is|number)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'es-ES': [
                        /(?:mi matrícula es|matrícula|mi número es|número)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ]
                };
                this.init();
            }

            init() {
                this.setupSpeechRecognition();
                this.setupLanguageDetection();
            }

            setupSpeechRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.error('Speech Recognition não suportado neste navegador');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = this.currentLanguage;
                this.recognition.maxAlternatives = 3;

                this.recognition.onstart = () => {
                    console.log('🎤 Iniciando reconhecimento de voz...');
                    this.isListening = true;
                    this.onVoiceStart();
                };

                this.recognition.onresult = (event) => {
                    this.processSpeechResult(event);
                };

                this.recognition.onerror = (event) => {
                    console.error('Erro no reconhecimento:', event.error);
                    this.handleRecognitionError(event.error);
                };

                this.recognition.onend = () => {
                    console.log('🔇 Reconhecimento finalizado');
                    this.isListening = false;
                    this.onVoiceEnd();
                };
            }

            setupLanguageDetection() {
                // Detectar idioma baseado no texto falado
                this.detectLanguage = (text) => {
                    const lowerText = text.toLowerCase();
                    
                    // Verificar padrões específicos de cada idioma
                    if (this.confusionPatterns['pt-BR'].some(pattern => lowerText.includes(pattern))) {
                        return 'pt-BR';
                    } else if (this.confusionPatterns['en-US'].some(pattern => lowerText.includes(pattern))) {
                        return 'en-US';
                    } else if (this.confusionPatterns['es-ES'].some(pattern => lowerText.includes(pattern))) {
                        return 'es-ES';
                    }
                    
                    // Fallback para português
                    return 'pt-BR';
                };
            }

            processSpeechResult(event) {
                // Verificar se já atingiu o máximo de tentativas
                if (this.attempts >= this.maxAttempts) {
                    console.log('🚫 Máximo de tentativas atingido, ignorando processamento');
                    return;
                }

                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Processar transcrição final
                if (finalTranscript) {
                    console.log('🎯 Transcrição final:', finalTranscript);
                    this.analyzeSpeech(finalTranscript);
                }

                // Mostrar transcrição interina
                if (interimTranscript) {
                    console.log('⏳ Processando:', interimTranscript);
                    this.onInterimResult(interimTranscript);
                }
            }

            analyzeSpeech(text) {
                const lowerText = text.toLowerCase().trim();
                const detectedLanguage = this.detectLanguage(lowerText);
                
                console.log(`🌍 Idioma detectado: ${detectedLanguage}`);
                console.log(`📝 Texto analisado: "${lowerText}"`);

                // NLU básico - classificar intenção
                const intent = this.classifyIntent(lowerText, detectedLanguage);
                console.log(`🧠 Intenção detectada: ${intent.type} (confiança: ${intent.confidence})`);

                // 1. Verificar se é confusão/dúvida
                if (intent.type === 'confusao' && intent.confidence > 0.7) {
                    console.log('❓ Confusão detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 2. Verificar se é dúvida
                if (intent.type === 'duvida' && intent.confidence > 0.7) {
                    console.log('❓ Dúvida detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 3. Tentar extrair matrícula
                const matricula = this.extractMatricula(lowerText, detectedLanguage);
                if (matricula) {
                    console.log(`✅ Matrícula extraída: ${matricula}`);
                    this.handleMatricula(matricula);
                    return;
                }

                // 4. Se não conseguiu extrair nada, incrementar tentativas
                this.attempts++;
                console.log(`⚠️ Tentativa ${this.attempts}/${this.maxAttempts} - Não foi possível extrair matrícula`);
                
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // NLU básico - classificar intenção
            classifyIntent(text, language) {
                const intents = {
                    'pt-BR': {
                        matricula: [
                            'matrícula', 'matricula', 'número', 'numero', 'código', 'codigo',
                            'minha matrícula é', 'meu número é', 'o número é', 'o código é'
                        ],
                        confusao: [
                            'não entendi', 'não compreendi', 'não saquei', 'não captei',
                            'o que é isso', 'o que é', 'como funciona', 'o que fazer',
                            'não sei', 'como usar', 'o que devo falar', 'não compreendi nada',
                            'não entendi nada', 'o que é para fazer', 'como funciona isso',
                            'não sei o que fazer', 'o que é isso aqui', 'como é que é',
                            'não entendi nada disso', 'o que é para falar', 'como usar isso',
                            'não sei como funciona', 'o que é para dizer', 'como é que funciona isso',
                            'ah, eu não entendi', 'eu não entendi o que tenho que falar',
                            'não entendi o que tenho que fazer', 'o que eu tenho que falar'
                        ],
                        duvida: [
                            'posso entrar sem crachá', 'preciso falar algo', 'o que preciso fazer',
                            'como faço para entrar', 'posso passar', 'o que devo fazer',
                            'como funciona aqui', 'o que é necessário', 'preciso de ajuda',
                            'não sei o que fazer', 'o que eu faço', 'como proceder'
                        ]
                    },
                    'en-US': {
                        matricula: [
                            'id', 'number', 'code', 'my id is', 'my number is', 'the number is',
                            'student id', 'id number', 'my code is'
                        ],
                        confusao: [
                            'i don\'t understand', 'i don\'t get it', 'what is this', 'what is',
                            'how does it work', 'what to do', 'i don\'t know', 'how to use',
                            'what should i say', 'i don\'t understand anything', 'what is this for',
                            'how do i use this', 'what am i supposed to do', 'i don\'t get how',
                            'what is this thing', 'how does this thing work', 'i don\'t know what to do',
                            'what is this here', 'how is this', 'i don\'t understand any of this',
                            'what am i supposed to say', 'how do i use this thing', 'i don\'t know how this works',
                            'what am i supposed to tell', 'how does this thing work', 'ah, i don\'t understand',
                            'i don\'t understand what i have to say', 'i don\'t understand what i have to do'
                        ],
                        duvida: [
                            'can i enter without badge', 'do i need to say something', 'what do i need to do',
                            'how do i enter', 'can i pass', 'what should i do', 'how does this work here',
                            'what is needed', 'i need help', 'i don\'t know what to do', 'what do i do',
                            'how to proceed'
                        ]
                    },
                    'es-ES': {
                        matricula: [
                            'matrícula', 'número', 'código', 'mi matrícula es', 'mi número es',
                            'el número es', 'el código es', 'código de estudiante'
                        ],
                        confusao: [
                            'no entiendo', 'no comprendo', 'no capto', 'qué es esto', 'qué es',
                            'cómo funciona', 'qué hacer', 'no sé', 'cómo usar', 'qué debo decir',
                            'no comprendo nada', 'no entiendo nada', 'qué es para hacer', 'cómo funciona esto',
                            'no sé qué hacer', 'qué es esto aquí', 'cómo es que es', 'no entiendo nada de esto',
                            'qué es para hablar', 'cómo usar esto', 'no sé cómo funciona', 'qué es para decir',
                            'cómo es que funciona esto', 'ah, no entiendo', 'no entiendo qué tengo que decir',
                            'no entiendo qué tengo que hacer'
                        ],
                        duvida: [
                            'puedo entrar sin credencial', 'necesito decir algo', 'qué necesito hacer',
                            'cómo hago para entrar', 'puedo pasar', 'qué debo hacer', 'cómo funciona aquí',
                            'qué es necesario', 'necesito ayuda', 'no sé qué hacer', 'qué hago',
                            'cómo proceder'
                        ]
                    }
                };

                const languageIntents = intents[language] || intents['pt-BR'];
                let bestIntent = { type: 'outros', confidence: 0 };

                // Verificar cada intenção
                for (const [intentType, patterns] of Object.entries(languageIntents)) {
                    let matches = 0;
                    let totalWords = text.split(' ').length;

                    for (const pattern of patterns) {
                        if (text.includes(pattern)) {
                            matches++;
                        }
                    }

                    const confidence = matches / Math.max(1, totalWords);
                    
                    if (confidence > bestIntent.confidence) {
                        bestIntent = { type: intentType, confidence: confidence };
                    }
                }

                return bestIntent;
            }

            isConfusion(text, language) {
                const patterns = this.confusionPatterns[language] || this.confusionPatterns['pt-BR'];
                return patterns.some(pattern => text.includes(pattern));
            }

            extractMatricula(text, language) {
                const patterns = this.matriculaPatterns[language] || this.matriculaPatterns['pt-BR'];
                
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[1] || match[0];
                    }
                }
                
                return null;
            }

            async handleConfusion(text, language) {
                console.log('🚨 Enviando alerta de confusão para Teams...');
                
                const now = new Date();
                const alertData = {
                    type: 'confusion',
                    text: text,
                    language: language,
                    timestamp: now.toISOString(),
                    priority: 'normal'
                };
                
                // Adicionar ao histórico de alertas
                this.alertHistory.push(alertData);
                
                // Limpar alertas antigos (mais de 5 minutos)
                this.alertHistory = this.alertHistory.filter(
                    alert => now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                // Verificar escalonamento
                const recentConfusions = this.alertHistory.filter(
                    alert => alert.type === 'confusion' && 
                    now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                if (recentConfusions.length >= this.alertThreshold) {
                    alertData.priority = recentConfusions.length >= this.highPriorityThreshold ? 'high' : 'medium';
                    console.log(`🚨 ESCALONAMENTO: ${recentConfusions.length} confusões em 5 minutos - Prioridade: ${alertData.priority}`);
                }
                
                // Salvar áudio de 5s no Supabase Storage
                const audioFileName = await this.saveAudioToSupabase('confusion', text, language);
                if (audioFileName) {
                    alertData.audioFile = audioFileName;
                }
                
                // Log de auditoria no Supabase
                this.logAuditEvent(alertData);
                
                // Enviar webhook com prioridade
                this.sendTeamsWebhook(alertData);
            }

            handleMatricula(matricula) {
                console.log(`🔍 Buscando usuário com matrícula: ${matricula}`);
                this.searchUser(matricula);
            }

            handleMaxAttemptsReached() {
                console.log('🚨 Máximo de tentativas atingido!');
                this.sendTeamsWebhook({
                    type: 'max_attempts',
                    priority: 'high',
                    attempts: this.attempts,
                    timestamp: new Date().toISOString()
                });
                this.attempts = 0;
                // Parar o reconhecimento de voz
                this.stopListening();
            }

            async searchUser(matricula) {
                try {
                    const { data, error } = await supabase
                        .from('usuarios')
                        .select('*')
                        .eq('matricula', matricula)
                        .maybeSingle();

                    if (error) {
                        console.error('Erro ao buscar usuário:', error);
                        return;
                    }

                    if (data) {
                        console.log('✅ Usuário encontrado:', data);
                        this.onUserFound(data);
                    } else {
                        console.log('❌ Usuário não encontrado');
                        this.onUserNotFound(matricula);
                    }
                } catch (error) {
                    console.error('Erro na busca:', error);
                }
            }

            sendTeamsWebhook(data) {
                // Webhook do Teams com CORS - usar proxy ou fallback
                console.log('📡 Tentando enviar webhook para Teams...');
                
                // Como há problema de CORS, vamos usar fallback direto
                this.sendEmailFallback(data);
                return;
                
                // Cores baseadas na prioridade
                const priorityColors = {
                    'normal': '0076D7',
                    'medium': 'FF8C00',
                    'high': 'DC143C'
                };
                
                const priorityEmojis = {
                    'normal': '🚨',
                    'medium': '⚠️',
                    'high': '🔥'
                };
                
                // Garantir que data.priority existe
                const priority = data.priority || 'normal';
                const color = priorityColors[priority] || priorityColors['normal'];
                const emoji = priorityEmojis[priority] || priorityEmojis['normal'];
                
                const message = {
                    "@type": "MessageCard",
                    "@context": "http://schema.org/extensions",
                    "themeColor": color,
                    "summary": `Alerta do Sistema de Voz - ${priority.toUpperCase()}`,
                    "sections": [{
                        "activityTitle": `${emoji} Alerta do Sistema de Reconhecimento de Voz`,
                        "activitySubtitle": `Tipo: ${data.type || 'confusao'} | Prioridade: ${priority.toUpperCase()}`,
                        "facts": [
                            { "name": "Timestamp", "value": data.timestamp },
                            { "name": "Tentativas", "value": data.attempts || 'N/A' },
                            { "name": "Texto", "value": data.text || 'N/A' },
                            { "name": "Idioma", "value": data.language || 'N/A' },
                            { "name": "Prioridade", "value": data.priority.toUpperCase() }
                        ]
                    }]
                };

                fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(message)
                }).then(response => {
                    if (response.ok) {
                        console.log('✅ Webhook Teams enviado com sucesso');
                        // Log status de sucesso
                        this.logAuditEvent({
                            ...data,
                            type: 'webhook_status',
                            status: 'teams_ok',
                            message: 'Webhook Teams enviado com sucesso'
                        });
                    } else {
                        console.error('Erro ao enviar webhook Teams:', response.status);
                        // Fallback para email se Teams falhar
                        this.sendEmailFallback(data);
                    }
                }).catch(error => {
                    console.error('Erro ao enviar webhook:', error);
                    // Fallback para email se Teams falhar
                    this.sendEmailFallback(data);
                });
            }

            // Fallback para email se Teams falhar
            sendEmailFallback(data) {
                console.log('📧 Enviando fallback por email...');
                // Aqui você pode implementar envio de email via API
                // Por exemplo, usando SendGrid, AWS SES, etc.
                this.logAuditEvent({
                    ...data,
                    type: 'email_fallback',
                    message: 'Teams webhook falhou, enviado por email'
                });
            }

            // Sistema de captura de áudio
            async setupAudioRecording() {
                try {
                    // Usar o mesmo AudioContext do setupAudioAnalysis
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: this.audioSampleRate
                        });
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: this.audioSampleRate,
                            channelCount: this.audioChannels,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    
                    // Usar AudioWorkletNode em vez de ScriptProcessorNode (deprecated)
                    if (this.audioContext.audioWorklet) {
                        try {
                            await this.audioContext.audioWorklet.addModule('data:application/javascript;base64,' + btoa(`
                                class AudioRecorderProcessor extends AudioWorkletProcessor {
                                    constructor() {
                                        super();
                                        this.bufferSize = 4096;
                                        this.buffer = [];
                                    }
                                    
                                    process(inputs, outputs, parameters) {
                                        const input = inputs[0];
                                        if (input.length > 0) {
                                            this.buffer.push(new Float32Array(input[0]));
                                            
                                            if (this.buffer.length > 100) { // ~5 segundos
                                                this.buffer.shift();
                                            }
                                            
                                            this.port.postMessage({
                                                type: 'audioData',
                                                data: new Float32Array(input[0])
                                            });
                                        }
                                        return true;
                                    }
                                }
                                registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
                            `));
                            
                            this.audioWorklet = new AudioWorkletNode(this.audioContext, 'audio-recorder-processor');
                            this.audioWorklet.port.onmessage = (event) => {
                                if (event.data.type === 'audioData' && this.isRecording) {
                                    this.audioBuffer.push(event.data.data);
                                    
                                    // Manter apenas os últimos 5 segundos
                                    const maxSamples = this.audioSampleRate * this.audioBufferSize;
                                    if (this.audioBuffer.length * 4096 > maxSamples) {
                                        this.audioBuffer.shift();
                                    }
                                }
                            };
                            
                            source.connect(this.audioWorklet);
                            console.log('🎙️ Sistema de gravação de áudio configurado (AudioWorklet)');
                        } catch (workletError) {
                            console.warn('AudioWorklet não suportado, usando ScriptProcessor:', workletError);
                            this.setupScriptProcessor(source);
                        }
                    } else {
                        this.setupScriptProcessor(source);
                    }
                } catch (error) {
                    console.error('Erro ao configurar gravação de áudio:', error);
                }
            }

            setupScriptProcessor(source) {
                const processor = this.audioContext.createScriptProcessor(4096, this.audioChannels, this.audioChannels);
                
                processor.onaudioprocess = (event) => {
                    if (this.isRecording) {
                        const inputData = event.inputBuffer.getChannelData(0);
                        this.audioBuffer.push(new Float32Array(inputData));
                        
                        // Manter apenas os últimos 5 segundos
                        const maxSamples = this.audioSampleRate * this.audioBufferSize;
                        if (this.audioBuffer.length * 4096 > maxSamples) {
                            this.audioBuffer.shift();
                        }
                    }
                };
                
                source.connect(processor);
                processor.connect(this.audioContext.destination);
                console.log('🎙️ Sistema de gravação de áudio configurado (ScriptProcessor)');
            }

            startAudioRecording() {
                this.isRecording = true;
                this.audioBuffer = [];
                console.log('🔴 Iniciando gravação de áudio...');
            }

            stopAudioRecording() {
                this.isRecording = false;
                console.log('⏹️ Parando gravação de áudio...');
            }

            async saveAudioToSupabase(eventType, text, language) {
                if (this.audioBuffer.length === 0) {
                    console.log('⚠️ Nenhum áudio para salvar');
                    return null;
                }

                try {
                    // Converter buffer para WAV
                    const wavBlob = this.audioToWav(this.audioBuffer);
                    
                    // Gerar nome único para o arquivo
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const fileName = `audio_${eventType}_${timestamp}.wav`;
                    
                    // Upload para Supabase Storage
                    const { data, error } = await supabase.storage
                        .from('voice-audio')
                        .upload(fileName, wavBlob, {
                            contentType: 'audio/wav',
                            cacheControl: '3600'
                        });

                    if (error) {
                        console.error('Erro ao fazer upload do áudio:', error);
                        return null;
                    }

                    console.log('✅ Áudio salvo no Supabase Storage:', fileName);
                    return fileName;
                } catch (error) {
                    console.error('Erro ao salvar áudio:', error);
                    return null;
                }
            }

            audioToWav(audioBuffer) {
                const length = audioBuffer.reduce((acc, buffer) => acc + buffer.length, 0);
                const arrayBuffer = new ArrayBuffer(44 + length * 2);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, this.audioChannels, true);
                view.setUint32(24, this.audioSampleRate, true);
                view.setUint32(28, this.audioSampleRate * this.audioChannels * 2, true);
                view.setUint16(32, this.audioChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 2, true);
                
                // Audio data
                let offset = 44;
                for (const buffer of audioBuffer) {
                    for (let i = 0; i < buffer.length; i++) {
                        const sample = Math.max(-1, Math.min(1, buffer[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            startListening() {
                if (this.recognition && !this.isListening) {
                    this.attempts = 0;
                    this.recognition.start();
                    this.startAudioRecording();
                }
            }

            stopListening() {
                if (this.recognition && this.isListening) {
                    this.recognition.stop();
                    this.stopAudioRecording();
                }
            }

            // Callbacks para integração com ondas sonoras
            onVoiceStart() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.startListening();
                }
            }

            onVoiceEnd() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.stopListening();
                }
            }

            onInterimResult(text) {
                if (window.sonicWaveform) {
                    // Simular intensidade baseada no comprimento do texto
                    const intensity = Math.min(1, text.length / 50);
                    window.sonicWaveform.updateVoiceData(intensity, 1, 1);
                }
            }

            // Web Audio API para análise de áudio em tempo real
            setupAudioAnalysis() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.audioSampleRate
                    });
                }
                
                if (!this.analyser) {
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.analyser.smoothingTimeConstant = 0.8;
                }
                
                if (!this.microphone) {
                    navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: this.audioSampleRate,
                            channelCount: this.audioChannels,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    })
                        .then(stream => {
                            this.microphone = this.audioContext.createMediaStreamSource(stream);
                            this.microphone.connect(this.analyser);
                            this.startAudioAnalysis();
                        })
                        .catch(error => console.error('Erro ao acessar microfone:', error));
                }
            }

            startAudioAnalysis() {
                if (!this.analyser) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const timeDomainData = new Float32Array(this.analyser.fftSize);
                
                // VAD (Voice Activity Detection) - detectar se é voz humana
                let voiceThreshold = 0.01; // Threshold para detectar voz
                let silenceCounter = 0;
                let maxSilenceFrames = 30; // 30 frames de silêncio = parar
                
                const analyze = () => {
                    if (this.isListening) {
                        this.analyser.getByteFrequencyData(dataArray);
                        this.analyser.getFloatTimeDomainData(timeDomainData);
                        
                        // Calcular RMS (Root Mean Square) para intensidade
                        const rms = Math.sqrt(dataArray.reduce((sum, value) => sum + value * value, 0) / dataArray.length) / 255;
                        
                        // VAD - detectar se é voz humana
                        const isVoice = this.detectVoice(dataArray, timeDomainData);
                        
                        if (isVoice) {
                            silenceCounter = 0;
                            
                            // FFT - Análise de frequência real
                            const frequencyData = this.analyzeFrequencySpectrum(dataArray);
                            
                            // Atualizar ondas sonoras com dados reais de voz
                            if (window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(
                                    frequencyData.intensity,
                                    frequencyData.dominantFreq,
                                    frequencyData.amplitude
                                );
                            }
                        } else {
                            silenceCounter++;
                            
                            // Se muito silêncio, reduzir intensidade das ondas
                            if (silenceCounter > maxSilenceFrames && window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(0.1, 0.5, 0.1);
                            }
                        }
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }

            // Detectar se é voz humana (VAD)
            detectVoice(frequencyData, timeDomainData) {
                // Calcular energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                
                // Calcular energia em frequências de voz (300Hz - 3400Hz)
                const voiceStart = Math.floor(300 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnd = Math.floor(3400 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnergy = frequencyData.slice(voiceStart, voiceEnd).reduce((sum, value) => sum + value, 0) / (voiceEnd - voiceStart);
                
                // Calcular energia em frequências de ruído (0-300Hz, 3400Hz+)
                const noiseEnergy = (frequencyData.slice(0, voiceStart).reduce((sum, value) => sum + value, 0) + 
                                   frequencyData.slice(voiceEnd).reduce((sum, value) => sum + value, 0)) / 
                                   (voiceStart + frequencyData.length - voiceEnd);
                
                // Detectar voz se energia de voz > ruído e total > threshold
                const voiceRatio = voiceEnergy / (noiseEnergy + 0.001);
                const isVoice = totalEnergy > this.voiceThreshold && voiceRatio > 1.5;
                
                return isVoice;
            }

            // Análise de espectro de frequência (FFT)
            analyzeFrequencySpectrum(frequencyData) {
                // Encontrar frequência dominante
                let maxValue = 0;
                let maxIndex = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                // Converter índice para frequência real
                const dominantFreq = (maxIndex * this.analyser.sampleRate) / (2 * frequencyData.length);
                
                // Calcular intensidade normalizada
                const intensity = maxValue / 255;
                
                // Calcular amplitude baseada na energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                const amplitude = Math.min(2, totalEnergy / 100);
                
                // Analisar formantes (características da voz)
                const formants = this.analyzeFormants(frequencyData);
                
                return {
                    intensity: intensity,
                    dominantFreq: Math.min(3, dominantFreq / 1000), // Normalizar para 0-3
                    amplitude: amplitude,
                    formants: formants
                };
            }

            // Análise de formantes (características únicas da voz)
            analyzeFormants(frequencyData) {
                const formants = [];
                const sampleRate = this.analyser.sampleRate;
                const nyquist = sampleRate / 2;
                
                // Procurar picos de energia (formantes)
                for (let i = 1; i < frequencyData.length - 1; i++) {
                    if (frequencyData[i] > frequencyData[i-1] && 
                        frequencyData[i] > frequencyData[i+1] && 
                        frequencyData[i] > 50) { // Threshold mínimo
                        
                        const freq = (i * nyquist) / frequencyData.length;
                        if (freq > 200 && freq < 4000) { // Range de formantes
                            formants.push({
                                frequency: freq,
                                amplitude: frequencyData[i] / 255
                            });
                        }
                    }
                }
                
                return formants;
            }

            onUserFound(user) {
                console.log('🎉 Usuário validado com sucesso!');
                // Redirecionar para tela de sucesso
                setTimeout(() => {
                    window.location.href = 'tela_depois_cracha.html';
                }, 1000);
            }

            onUserNotFound(matricula) {
                console.log('❌ Matrícula não encontrada no sistema');
                this.attempts++;
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // Log de auditoria no Supabase
            async logAuditEvent(eventData) {
                try {
                    const { error } = await supabase
                        .from('audit_logs')
                        .insert([{
                            event_type: eventData.type,
                            text: eventData.text,
                            language: eventData.language,
                            attempts: eventData.attempts || 0,
                            timestamp: eventData.timestamp,
                            created_at: new Date().toISOString()
                        }]);

                    if (error) {
                        console.error('Erro ao salvar log de auditoria:', error);
                    } else {
                        console.log('✅ Log de auditoria salvo com sucesso');
                    }
                } catch (error) {
                    console.error('Erro na função de log:', error);
                }
            }
        }
        */

        // Sonic Waveform Canvas Class
        class SonicWaveformCanvas {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { willReadFrequently: true });
                this.animationFrameId = null;
                this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };
                this.time = 0;
                
                // Voice detection properties
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.draw();
                this.setupEventListeners();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            draw() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const lineCount = 60;
                const segmentCount = 80;
                const height = this.canvas.height / 2;
                
                // Voice detection effects
                const voiceEffect = this.isListening ? this.voiceIntensity : 0;
                const voiceAmplitude = this.isListening ? this.voiceAmplitude : 1;
                const voiceFreq = this.isListening ? this.voiceFrequency : 1;
                
                for (let i = 0; i < lineCount; i++) {
                    this.ctx.beginPath();
                    const progress = i / lineCount;
                    const colorIntensity = Math.sin(progress * Math.PI);
                    
                    // Voice affects color intensity
                    const voiceColorIntensity = colorIntensity * (1 + voiceEffect * 0.5);
                    this.ctx.strokeStyle = `rgba(0, 255, 192, ${voiceColorIntensity * 0.5})`;
                    this.ctx.lineWidth = 1.5 + (voiceEffect * 2);

                    for (let j = 0; j < segmentCount + 1; j++) {
                        const x = (j / segmentCount) * this.canvas.width;
                        
                        // Mouse influence (desabilitado para touch screen)
                        const distToMouse = Math.hypot(x - this.mouse.x, (height) - this.mouse.y);
                        const mouseEffect = Math.max(0, 1 - distToMouse / 400);

                        // Wave calculation with voice effects
                        const noise = Math.sin(j * 0.1 + this.time + i * 0.2) * 20;
                        const spike = Math.cos(j * 0.2 + this.time + i * 0.1) * Math.sin(j * 0.05 + this.time) * 50;
                        
                        // Voice detection adds dynamic effects
                        const voiceNoise = this.isListening ? 
                            Math.sin(j * voiceFreq * 0.1 + this.time + i * 0.2) * 30 * voiceEffect : 0;
                        const voiceSpike = this.isListening ? 
                            Math.cos(j * voiceFreq * 0.2 + this.time + i * 0.1) * Math.sin(j * voiceFreq * 0.05 + this.time) * 80 * voiceEffect : 0;
                        
                        const y = height + noise + spike * (1 + mouseEffect * 2) + 
                                 voiceNoise + voiceSpike * voiceAmplitude;
                        
                        if (j === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                }

                this.time += 0.02;
                this.animationFrameId = requestAnimationFrame(() => this.draw());
            }

            setupEventListeners() {
                const handleResize = () => {
                    this.resizeCanvas();
                };

                window.addEventListener('resize', handleResize);
                
                // Cleanup function
                this.cleanup = () => {
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                    }
                    window.removeEventListener('resize', handleResize);
                };
            }

            resize() {
                this.resizeCanvas();
            }

            destroy() {
                if (this.cleanup) {
                    this.cleanup();
                }
            }

            // Voice detection methods
            startListening() {
                this.isListening = true;
                this.voiceIntensity = 0.5;
                this.voiceFrequency = 1;
                this.voiceAmplitude = 1;
            }

            stopListening() {
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
            }

            updateVoiceData(intensity, frequency, amplitude) {
                this.voiceIntensity = Math.min(1, Math.max(0, intensity));
                this.voiceFrequency = Math.min(3, Math.max(0.5, frequency));
                this.voiceAmplitude = Math.min(2, Math.max(0.5, amplitude));
            }

            // Simulate voice detection for testing
            simulateVoiceDetection() {
                if (this.isListening) {
                    // Simulate random voice data
                    const intensity = 0.3 + Math.random() * 0.7;
                    const frequency = 0.8 + Math.random() * 1.4;
                    const amplitude = 0.8 + Math.random() * 1.2;
                    
                    this.updateVoiceData(intensity, frequency, amplitude);
                }
            }
        }

        // Sistema de Scanner de Código de Barras - REMOVIDO
        /*
        class BarcodeScanner {
            constructor() {
                this.isScanning = false;
                this.currentStream = null;
                this.supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
                this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
                this.supabase = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'environment'
                        } 
                    });
                    
                    this.currentStream = stream;
                    const video = document.getElementById('scannerVideo');
                    video.srcObject = stream;
                    
                    video.onloadedmetadata = () => {
                        video.play();
                        // Aguardar o vídeo estar reproduzindo antes de iniciar o scanner
                        video.onplaying = () => {
                            console.log('Vídeo está reproduzindo, iniciando scanner...');
                            setTimeout(() => {
                                this.startScanner();
                            }, 1000); // Aguardar 1 segundo para garantir estabilidade
                        };
                    };
                    
                } catch (error) {
                    console.error('Erro ao acessar webcam:', error);
                    this.showError('Webcam não disponível');
                }
            }

            startScanner() {
                if (this.isScanning) return;
                
                console.log('Iniciando scanner de código de barras...');
                this.isScanning = true;
                const videoElement = document.getElementById('scannerVideo');
                
                if (!videoElement) {
                    console.error('Elemento de vídeo não encontrado');
                    this.showError('Elemento de vídeo não encontrado');
                    return;
                }
                
                console.log('Elemento de vídeo encontrado:', videoElement);
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: videoElement,
                        constraints: {
                            width: 640,
                            height: 480,
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader",
                            "ean_reader",
                            "code_39_reader",
                            "ean_8_reader",
                            "upc_reader"
                        ],
                        debug: {
                            drawBoundingBox: true,
                            showFrequency: false,
                            showDetectedRegion: false,
                            showSkeleton: false,
                            showLabels: false,
                            showPatch: false,
                            showBoxes: false
                        }
                    },
                    locate: true,
                    locator: {
                        patchSize: "large",
                        halfSample: false
                    },
                    numOfWorkers: 2,
                    frequency: 10,
                    debug: false
                }, (err) => {
                    if (err) {
                        console.error('Erro ao inicializar scanner:', err);
                        this.showError('Erro ao inicializar scanner');
                        return;
                    }
                    
                    console.log('Scanner inicializado com sucesso');
                    Quagga.start();
                    this.showQualityIndicator();
                    
                    // Adicionar listener para debug de processamento
                    let frameCount = 0;
                    Quagga.onProcessed((result) => {
                        frameCount++;
                        if (frameCount % 30 === 0) {
                            console.log('🔄 Processando frame...', frameCount);
                        }
                        if (result && result.codeResult) {
                            console.log('🎯 Código encontrado no processamento:', result.codeResult);
                        }
                    });
                });
                
                Quagga.onDetected((result) => {
                    console.log('🎯 Código detectado pelo Quagga:', result);
                    if (result && result.codeResult) {
                        const code = result.codeResult.code;
                        const confidence = result.codeResult.confidence;
                        console.log('✅ Código válido detectado:', code, 'Confiança:', confidence);
                        
                        Quagga.stop();
                        this.isScanning = false;
                        this.searchUser(code);
                    } else {
                        console.log('❌ Resultado inválido:', result);
                    }
                });
            }

            async searchUser(codigoBarras) {
                try {
                    this.showFeedback('Verificando acesso...', 'info');
                    
                    const { data, error } = await this.supabase
                        .from('usuarios')
                        .select('nome_completo, empresa')
                        .eq('codigo_barras', codigoBarras)
                        .maybeSingle();
                    
                    if (error) {
                        console.error('Erro na consulta:', error);
                        this.showFeedback('Erro na consulta do banco de dados', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    } else if (data) {
                        console.log('Usuário encontrado:', data);
                        this.showFeedback(`Acesso autorizado - ${data.nome_completo}!`, 'success');
                        setTimeout(() => {
                            this.redirectToWelcome(data.nome_completo);
                        }, 1500);
                    } else {
                        console.log('Usuário não encontrado');
                        this.showFeedback('Acesso negado - Usuário não cadastrado', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    }
                    
                } catch (error) {
                    console.error('Erro na busca:', error);
                    this.showFeedback('Erro interno do sistema', 'error');
                    setTimeout(() => this.restartScanner(), 3000);
                }
            }

            showFeedback(message, type) {
                const feedback = document.createElement('div');
                feedback.className = `fixed top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg text-white font-semibold z-50 ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    'bg-blue-500'
                }`;
                feedback.textContent = message;
                
                document.body.appendChild(feedback);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.remove();
                    }
                }, 3000);
            }

            redirectToWelcome(nomeCompleto) {
                const primeiroNome = nomeCompleto.split(' ')[0];
                localStorage.setItem('usuarioNome', primeiroNome);
                window.location.href = 'tela_depois_cracha.html';
            }

            restartScanner() {
                if (this.isScanning) return;
                
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner já estava parado');
                }
                
                setTimeout(() => {
                    this.startScanner();
                }, 1000);
            }

            showQualityIndicator() {
                const indicator = document.getElementById('qualityIndicator');
                if (indicator) {
                    indicator.style.display = 'block';
                }
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                if (errorDiv) {
                    errorDiv.style.display = 'flex';
                    errorDiv.querySelector('p').textContent = message;
                }
            }

            stop() {
                this.isScanning = false;
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner já estava parado');
                }
                
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
            }
        }
        */

        // YOLOv11 Person Detection Class (ONNX)
        class YOLOv11Detector {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.personCount = 0;
                this.personRequired = 2; // Detecções necessárias
                this.statusElement = document.getElementById('statusText');
                this.redirectDelay = 2000; // 2 segundos antes de redirecionar
                this.redirectTimeout = null;
                this.lastDetectionTime = 0;
                this.detectionInterval = 150; // Detectar a cada 150ms
                this.session = null;
                this.inputShape = [1, 3, 640, 640]; // YOLOv11 input shape
                this.config = {
                    minConfidence: 0.5, // 50% de confiança mínima
                    nmsThreshold: 0.4, // Non-Maximum Suppression
                    maxDetections: 5, // Máximo 5 pessoas
                    realTime: true // Tempo real
                };
                this.classNames = ['person']; // Apenas detecção de pessoas
            }

            async init() {
                try {
                    // Solicitar acesso à câmera (oculta)
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user' // Câmera frontal
                        } 
                    });

                    // Criar elementos ocultos para detecção
                    this.video = document.createElement('video');
                    this.canvas = document.createElement('canvas');
                    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

                    // Configurar vídeo (oculto)
                    this.video.srcObject = stream;
                    this.video.play();
                    this.video.style.display = 'none';
                    document.body.appendChild(this.video);

                    // Configurar canvas (oculto)
                    this.canvas.width = 200;
                    this.canvas.height = 150;
                    this.canvas.style.display = 'none';
                    document.body.appendChild(this.canvas);

                    // Aguardar vídeo carregar
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Inicializar detecção de pessoa
                    await this.initYOLOv11();
                    console.log('Detecção de pessoa ativa (oculta)');

                } catch (error) {
                    console.error('Erro ao acessar câmera:', error);
                    console.log('Detecção de pessoa desabilitada');
                }
            }

            async initYOLOv11() {
                try {
                    // Usar apenas COCO-SSD para evitar problemas de CORS
                    console.log('Carregando COCO-SSD para detecção de pessoas...');
                    
                    this.model = await cocoSsd.load({
                        base: 'mobilenet_v2',
                        version: 'lite_mobilenet_v2'
                    });
                    console.log('COCO-SSD carregado com sucesso');
                    this.updateStatus('COCO-SSD ativo - Detectando pessoas...');
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Erro ao carregar COCO-SSD:', error);
                    this.updateStatus('Erro na inicialização - Clique para continuar');
                }
            }

            startDetection() {
                if (!this.video || !this.model) {
                    console.error('Vídeo ou modelo não inicializado');
                    return;
                }

                const detectPersons = async () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        const now = Date.now();
                        if (now - this.lastDetectionTime > this.detectionInterval) {
                            try {
                                // Usar apenas COCO-SSD
                                const predictions = await this.model.detect(this.video);
                                this.onPersonDetectionResults(predictions);
                                this.lastDetectionTime = now;
                            } catch (error) {
                                console.error('Erro na detecção:', error);
                            }
                        }
                    }

                    if (this.isDetecting) {
                        requestAnimationFrame(detectPersons);
                    }
                };

                this.isDetecting = true;
                console.log('Iniciando detecção de pessoas...');
                detectPersons();
            }


            onPersonDetectionResults(predictions) {
                // Limpar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Filtrar apenas detecções de pessoas com alta confiança
                const persons = predictions.filter(prediction => 
                    prediction.class === 'person' && 
                    prediction.score > this.config.minConfidence
                );

                if (persons.length > 0) {
                    console.log(`Detectou ${persons.length} pessoa(s)`);
                    
                    // Desenhar informações das pessoas
                    this.drawPersonInformation(persons);

                    // Incrementar contador de pessoas
                    this.personCount++;
                    this.updateStatus(`Pessoa detectada! (${this.personCount}/${this.personRequired})`);
                    
                    if (this.personCount >= this.personRequired) {
                        this.handlePersonDetected();
                    }
                } else {
                    this.personCount = Math.max(0, this.personCount - 1);
                    this.updateStatus('Detectando pessoas...');
                }
            }

            drawPersonInformation(persons) {
                persons.forEach((person, index) => {
                    const { x, y, width, height } = person.bbox;
                    
                    // Escalar coordenadas para o canvas da preview
                    const scaleX = this.canvas.width / this.video.videoWidth;
                    const scaleY = this.canvas.height / this.video.videoHeight;
                    
                    const scaledX = x * scaleX;
                    const scaledY = y * scaleY;
                    const scaledWidth = width * scaleX;
                    const scaledHeight = height * scaleY;

                    // Cores YOLOv11
                    const colors = ['#00FF88', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const color = colors[index % colors.length];
                    const borderColor = color;

                    // Desenhar bounding box da pessoa
                    this.ctx.strokeStyle = borderColor;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);

                    // Informações da pessoa
                    const info = [];
                    info.push(`Pessoa: ${(person.score * 100).toFixed(1)}%`);
                    
                    const labelText = info.join(' | ');
                    const labelWidth = this.ctx.measureText(labelText).width + 10;
                    const labelHeight = 20;
                    
                    // Fundo do label
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY - labelHeight, labelWidth, labelHeight);
                    
                    // Texto do label
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.fillText(labelText, scaledX + 5, scaledY - 5);

                    // Indicador de confiança
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY + scaledHeight + 2, scaledWidth * person.score, 3);
                });

                // Barra de progresso geral
                const progressWidth = this.canvas.width - 40;
                const progressHeight = 6;
                const progressX = 20;
                const progressY = this.canvas.height - 20;
                
                // Fundo da barra
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Barra de progresso
                const progress = this.personCount / this.personRequired;
                this.ctx.fillStyle = '#00FF88';
                this.ctx.fillRect(progressX, progressY, progressWidth * progress, progressHeight);
            }

            handlePersonDetected() {
                this.updateStatus('Pessoa detectada! Aguardando 5 segundos...');
                this.isDetecting = false;

                // Parar a câmera
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                // Contador regressivo de 5 segundos
                let countdown = 5;
                const countdownInterval = setInterval(() => {
                    this.updateStatus(`Pessoa detectada! Redirecionando em ${countdown} segundos...`);
                    countdown--;
                    
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.updateStatus('Pessoa detectada! Redirecionando...');
                        
                        // Alternar para reconhecimento facial após 5 segundos
                        setTimeout(() => {
                            switchToFaceDetection();
                        }, 1000);
                    }
                }, 1000);

            }

            updateStatus(message) {
                // Status removido - detecção oculta
                console.log('Status:', message);
            }

            // Método para otimizar performance do YOLOv11
            optimizeForYOLOv11() {
                // Ajustar configurações baseado na performance
                const fps = 1000 / this.detectionInterval;
                if (fps < 8) {
                    this.detectionInterval = 150; // Reduzir frequência se muito lento
                    this.config.minConfidence = 0.8; // Aumentar threshold
                } else if (fps > 12) {
                    this.detectionInterval = 80; // Aumentar frequência se muito rápido
                    this.config.minConfidence = 0.6; // Diminuir threshold
                }
            }


            stop() {
                this.isDetecting = false;
                if (this.redirectTimeout) {
                    clearTimeout(this.redirectTimeout);
                }
                // Limpar qualquer countdown ativo
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                // Remover elementos criados dinamicamente
                if (this.video && this.video.parentNode) {
                    this.video.parentNode.removeChild(this.video);
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
            }
        }

        // Scanner de código de barras removido - apenas sistema de voz

        // Função global para reiniciar reconhecimento facial
        function restartFacialRecognition() {
            console.log('🔄 Reiniciando sistema de reconhecimento facial...');
            
            if (window.faceDetector) {
                // Esconder botão de reiniciar
                window.faceDetector.hideRestartButton();
                
                // Reiniciar detecção
                window.faceDetector.startDetection();
                
                // Resetar título
                const titleElement = document.querySelector('.scanner-title');
                if (titleElement) {
                    titleElement.textContent = 'Reconhecimento Facial';
                    titleElement.style.color = '#00FFC0';
                    titleElement.style.fontSize = '2rem';
                    titleElement.style.fontWeight = 'normal';
                    titleElement.style.textShadow = 'none';
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('vortexCanvas');
            const sonicWaveform = new SonicWaveformCanvas(canvas);
            window.sonicWaveform = sonicWaveform;

            // Inicializar detector YOLOv11 de pessoas
            const yoloDetector = new YOLOv11Detector();
            yoloDetector.init();

            // Inicializar sistema de reconhecimento facial
            const faceDetector = new CompreFaceDetector();
            window.faceDetector = faceDetector;

            // Handle window resize
            window.addEventListener('resize', () => {
                sonicWaveform.resize();
            });

            // Limpar recursos ao sair da página
            window.addEventListener('beforeunload', () => {
                sonicWaveform.destroy();
                yoloDetector.stop();
            });
        });

        // Sistema de alternância entre telas
        let currentScreen = 'idle';
        let faceDetectorInitialized = false;
        let idleTimeout = null;
        const IDLE_TIMEOUT = 30000; // 30 segundos

        function switchToFaceDetection() {
            if (currentScreen === 'face') return;
            
            currentScreen = 'face';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Ocultar tela de descanso
            document.getElementById('idleScreen').style.display = 'none';
            
            // Mostrar tela de reconhecimento facial
            const faceScreen = document.getElementById('scannerScreen');
            faceScreen.style.display = 'flex';
            
            // Ativar animação
            setTimeout(() => {
                faceScreen.classList.add('active');
            }, 50);
            
            // Inicializar detector facial se ainda não foi inicializado
            if (!faceDetectorInitialized && window.faceDetector) {
                window.faceDetector.init();
                faceDetectorInitialized = true;
            }
            
            // Configurar timeout para voltar à tela de descanso
            idleTimeout = setTimeout(() => {
                switchToIdle();
            }, IDLE_TIMEOUT);
        }

        function switchToIdle() {
            if (currentScreen === 'idle') return;
            
            currentScreen = 'idle';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Parar detector facial
            if (window.faceDetector) {
                window.faceDetector.stop();
            }
            
            // Ocultar tela de reconhecimento facial
            const faceScreen = document.getElementById('scannerScreen');
            faceScreen.classList.remove('active');
            
            setTimeout(() => {
                faceScreen.style.display = 'none';
                document.getElementById('idleScreen').style.display = 'flex';
            }, 800);
        }

        // Alternar para tela de reconhecimento facial ao clicar
        document.addEventListener('click', function() {
            switchToFaceDetection();
        });

        // Alternar para tela de reconhecimento facial ao tocar (mobile)
        document.addEventListener('touchstart', function() {
            switchToFaceDetection();
        });

        // Prevenir comportamento padrão de toque
        document.addEventListener('touchend', function(e) {
            e.preventDefault();
        });

    </script>
</body>
</html>
