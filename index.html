<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Innovate Hub - Sistema de Recep√ß√£o</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            cursor: pointer;
        }

        .vortex-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .vortex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }

         .logo-conexo {
             max-width: 500px;
             height: auto;
             margin-bottom: 2rem;
             filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.7));
             animation: fadeInUp 2s ease-out;
         }

        .hub-text {
            color: #ffffff;
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            margin-top: 12rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            animation: fadeInUp 2s ease-out 0.3s both;
        }

        .logo-randoncorp {
            max-width: 250px;
            height: auto;
            margin-top: 0.5rem;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
            animation: fadeInUp 2s ease-out 0.6s both;
        }


        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        /* Estilos da Tela de Scanner */
        .scanner-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s ease-in-out;
        }

        .scanner-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        .scanner-container {
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .scanner-icon {
            margin-bottom: 2rem;
        }

        .scanner-icon .material-symbols-outlined {
            font-size: 100px;
            color: #39E079;
        }

        .scanner-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #00f0ff, #7f00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .scanner-subtitle {
            font-size: 1.125rem;
            color: #8888a0;
            margin-bottom: 3rem;
        }

        .scanner-video-container {
            position: relative;
            width: 288px;
            height: 192px;
            margin: 0 auto 3rem;
            border: 2px solid #39E079;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(57, 224, 121, 0.3);
            animation: holographic-pulse 3s infinite alternate;
        }

        .scanner-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scan-line-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #39E079;
            box-shadow: 0 0 10px #39E079, 0 0 20px #39E079;
            animation: scanLine 2s linear infinite;
            z-index: 10;
        }

        .scanner-border {
            position: absolute;
            inset: 0;
            border: 2px solid rgba(127, 0, 255, 0.5);
            pointer-events: none;
        }

        .quality-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            display: none;
        }

        .error-message {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(18, 32, 23, 0.8);
            border-radius: 0.5rem;
        }

        .error-message .material-symbols-outlined {
            font-size: 48px;
            color: #ef4444;
            margin-bottom: 0.5rem;
        }

        .error-message p {
            color: #ef4444;
            font-size: 0.875rem;
        }

        .scanner-help {
            font-size: 0.875rem;
            color: #8888a0;
        }

        /* Instru√ß√µes de voz */
        .voice-instructions {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: #e2e8f0;
            font-size: 0.9rem;
        }

        .instruction-item .material-symbols-outlined {
            color: #10b981;
            font-size: 1.25rem;
        }


        @keyframes scanLine {
            0% { transform: translateY(0px); opacity: 1; }
            50% { transform: translateY(192px); opacity: 1; }
            100% { transform: translateY(0px); opacity: 1; }
        }

        @keyframes holographic-pulse {
            0% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
            50% { box-shadow: 0 0 20px #7f00ff, 0 0 40px #7f00ff, inset 0 0 20px #7f00ff; }
            100% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
        }
    </style>
</head>
<body>
    <div class="vortex-container">
        <canvas id="vortexCanvas" class="vortex-canvas"></canvas>
                <!-- Tela de Descanso -->
                <div class="content" id="idleScreen">
                    <img src="conexo-logo.png" alt="Conexo Logo" class="logo-conexo">
                    <div class="hub-text">Hub de inova√ß√£o da</div>
                    <img src="randoncorp-png.png" alt="RandonCorp Logo" class="logo-randoncorp">
                </div>

        <!-- Tela de Scanner -->
        <div class="scanner-content" id="scannerScreen" style="display: none;">
            <div class="scanner-container">
                <div class="scanner-icon">
                    <span class="material-symbols-outlined">mic</span>
                </div>
                <h1 class="scanner-title">Sistema de Reconhecimento de Voz</h1>
                <p class="scanner-subtitle">Fale sua matr√≠cula ou solicite ajuda chamando a recep√ß√£o.</p>
                
                <!-- Instru√ß√µes de uso -->
                <div class="voice-instructions">
                    <div class="instruction-item">
                        <span class="material-symbols-outlined">mic</span>
                        <span>Fale claramente sua matr√≠cula</span>
                    </div>
                    <div class="instruction-item">
                        <span class="material-symbols-outlined">help</span>
                        <span>Se precisar de ajuda, chame a recep√ß√£o</span>
                    </div>
                    <div class="instruction-item">
                        <span class="material-symbols-outlined">language</span>
                        <span>Suporta Portugu√™s, Ingl√™s e Espanhol</span>
                    </div>
                </div>
                
                <div class="scanner-video-container">
                    <video id="scannerVideo" class="scanner-video" autoplay muted playsinline></video>
                    <div class="scan-line-overlay"></div>
                    <div class="scanner-border"></div>
                    
                    <!-- Indicador de qualidade -->
                    <div id="qualityIndicator" class="quality-indicator">
                        <span id="qualityText">Detectando...</span>
                    </div>

                    <div id="errorMessage" class="error-message">
                        <span class="material-symbols-outlined">videocam_off</span>
                        <p>Webcam n√£o dispon√≠vel</p>
                    </div>
                </div>
                
                <p class="scanner-help">Problemas de acesso? Contate o suporte t√©cnico hologr√°fico.</p>
                
                <!-- Bot√£o para iniciar sistema de voz -->
                <button id="voiceStartBtn" class="mt-6 px-8 py-4 bg-teal-500 text-white rounded-lg hover:bg-teal-600 transition-colors text-lg font-semibold">
                    üé§ Iniciar Reconhecimento de Voz
                </button>
            </div>
        </div>
        
    </div>

    <!-- Depend√™ncias -->
    <script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <script>

        // Sistema de Reconhecimento de Voz com IA
        class VoiceRecognitionSystem {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.attempts = 0;
                this.maxAttempts = 2;
                this.currentLanguage = 'pt-BR';
                this.languages = ['pt-BR', 'en-US', 'es-ES'];
                
                // Sistema de escalonamento de alertas
                this.alertHistory = [];
                this.alertThreshold = 3; // 3 confus√µes em 5 minutos
                this.alertWindow = 5 * 60 * 1000; // 5 minutos em ms
                this.highPriorityThreshold = 5; // 5 confus√µes = prioridade alta
                
                // Sistema de captura de √°udio
                this.audioBuffer = [];
                this.audioBufferSize = 5; // 5 segundos
                this.audioSampleRate = 44100;
                this.audioChannels = 1;
                this.audioContext = null;
                this.audioWorklet = null;
                this.isRecording = false;
                this.confusionPatterns = {
                    'pt-BR': [
                        'o que √© isso', 'n√£o entendi', 'como funciona', 'o que fazer',
                        'n√£o sei', 'como usar', 'o que devo falar', 'n√£o compreendi',
                        'o que √©', 'como √© que funciona', 'n√£o entendi nada', 'n√£o saquei',
                        'n√£o compreendi nada', 'o que devo fazer', 'como √© que usa',
                        'n√£o entendi como', 'o que √© para fazer', 'como funciona isso',
                        'n√£o sei o que fazer', 'o que √© isso aqui', 'como √© que √©',
                        'n√£o entendi nada disso', 'o que √© para falar', 'como usar isso',
                        'n√£o sei como funciona', 'o que √© para dizer', 'como √© que funciona isso'
                    ],
                    'en-US': [
                        'what is this', 'i don\'t understand', 'how does it work', 'what to do',
                        'i don\'t know', 'how to use', 'what should i say', 'i don\'t get it',
                        'what is', 'how does this work', 'i don\'t understand anything',
                        'what is this for', 'how do i use this', 'what am i supposed to do',
                        'i don\'t get how', 'what is this thing', 'how does this thing work',
                        'i don\'t know what to do', 'what is this here', 'how is this',
                        'i don\'t understand any of this', 'what am i supposed to say',
                        'how do i use this thing', 'i don\'t know how this works',
                        'what am i supposed to tell', 'how does this thing work'
                    ],
                    'es-ES': [
                        'qu√© es esto', 'no entiendo', 'c√≥mo funciona', 'qu√© hacer',
                        'no s√©', 'c√≥mo usar', 'qu√© debo decir', 'no comprendo',
                        'qu√© es', 'c√≥mo funciona esto', 'no entiendo nada', 'no capto',
                        'no comprendo nada', 'qu√© debo hacer', 'c√≥mo es que se usa',
                        'no entiendo c√≥mo', 'qu√© es para hacer', 'c√≥mo funciona esto',
                        'no s√© qu√© hacer', 'qu√© es esto aqu√≠', 'c√≥mo es que es',
                        'no entiendo nada de esto', 'qu√© es para hablar', 'c√≥mo usar esto',
                        'no s√© c√≥mo funciona', 'qu√© es para decir', 'c√≥mo es que funciona esto'
                    ]
                };
                this.matriculaPatterns = {
                    'pt-BR': [
                        /(?:minha matr√≠cula √©|matr√≠cula|matricula|meu n√∫mero √©|n√∫mero)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'en-US': [
                        /(?:my id is|id number|student id|my number is|number)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'es-ES': [
                        /(?:mi matr√≠cula es|matr√≠cula|mi n√∫mero es|n√∫mero)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ]
                };
                this.init();
            }

            init() {
                this.setupSpeechRecognition();
                this.setupLanguageDetection();
            }

            setupSpeechRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.error('Speech Recognition n√£o suportado neste navegador');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = this.currentLanguage;
                this.recognition.maxAlternatives = 3;

                this.recognition.onstart = () => {
                    console.log('üé§ Iniciando reconhecimento de voz...');
                    this.isListening = true;
                    this.onVoiceStart();
                };

                this.recognition.onresult = (event) => {
                    this.processSpeechResult(event);
                };

                this.recognition.onerror = (event) => {
                    console.error('Erro no reconhecimento:', event.error);
                    this.handleRecognitionError(event.error);
                };

                this.recognition.onend = () => {
                    console.log('üîá Reconhecimento finalizado');
                    this.isListening = false;
                    this.onVoiceEnd();
                };
            }

            setupLanguageDetection() {
                // Detectar idioma baseado no texto falado
                this.detectLanguage = (text) => {
                    const lowerText = text.toLowerCase();
                    
                    // Verificar padr√µes espec√≠ficos de cada idioma
                    if (this.confusionPatterns['pt-BR'].some(pattern => lowerText.includes(pattern))) {
                        return 'pt-BR';
                    } else if (this.confusionPatterns['en-US'].some(pattern => lowerText.includes(pattern))) {
                        return 'en-US';
                    } else if (this.confusionPatterns['es-ES'].some(pattern => lowerText.includes(pattern))) {
                        return 'es-ES';
                    }
                    
                    // Fallback para portugu√™s
                    return 'pt-BR';
                };
            }

            processSpeechResult(event) {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Processar transcri√ß√£o final
                if (finalTranscript) {
                    console.log('üéØ Transcri√ß√£o final:', finalTranscript);
                    this.analyzeSpeech(finalTranscript);
                }

                // Mostrar transcri√ß√£o interina
                if (interimTranscript) {
                    console.log('‚è≥ Processando:', interimTranscript);
                    this.onInterimResult(interimTranscript);
                }
            }

            analyzeSpeech(text) {
                const lowerText = text.toLowerCase().trim();
                const detectedLanguage = this.detectLanguage(lowerText);
                
                console.log(`üåç Idioma detectado: ${detectedLanguage}`);
                console.log(`üìù Texto analisado: "${lowerText}"`);

                // NLU b√°sico - classificar inten√ß√£o
                const intent = this.classifyIntent(lowerText, detectedLanguage);
                console.log(`üß† Inten√ß√£o detectada: ${intent.type} (confian√ßa: ${intent.confidence})`);

                // 1. Verificar se √© confus√£o/d√∫vida
                if (intent.type === 'confusao' && intent.confidence > 0.7) {
                    console.log('‚ùì Confus√£o detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 2. Verificar se √© d√∫vida
                if (intent.type === 'duvida' && intent.confidence > 0.7) {
                    console.log('‚ùì D√∫vida detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 3. Tentar extrair matr√≠cula
                const matricula = this.extractMatricula(lowerText, detectedLanguage);
                if (matricula) {
                    console.log(`‚úÖ Matr√≠cula extra√≠da: ${matricula}`);
                    this.handleMatricula(matricula);
                    return;
                }

                // 4. Se n√£o conseguiu extrair nada, incrementar tentativas
                this.attempts++;
                console.log(`‚ö†Ô∏è Tentativa ${this.attempts}/${this.maxAttempts} - N√£o foi poss√≠vel extrair matr√≠cula`);
                
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // NLU b√°sico - classificar inten√ß√£o
            classifyIntent(text, language) {
                const intents = {
                    'pt-BR': {
                        matricula: [
                            'matr√≠cula', 'matricula', 'n√∫mero', 'numero', 'c√≥digo', 'codigo',
                            'minha matr√≠cula √©', 'meu n√∫mero √©', 'o n√∫mero √©', 'o c√≥digo √©'
                        ],
                        confusao: [
                            'n√£o entendi', 'n√£o compreendi', 'n√£o saquei', 'n√£o captei',
                            'o que √© isso', 'o que √©', 'como funciona', 'o que fazer',
                            'n√£o sei', 'como usar', 'o que devo falar', 'n√£o compreendi nada',
                            'n√£o entendi nada', 'o que √© para fazer', 'como funciona isso',
                            'n√£o sei o que fazer', 'o que √© isso aqui', 'como √© que √©',
                            'n√£o entendi nada disso', 'o que √© para falar', 'como usar isso',
                            'n√£o sei como funciona', 'o que √© para dizer', 'como √© que funciona isso',
                            'ah, eu n√£o entendi', 'eu n√£o entendi o que tenho que falar',
                            'n√£o entendi o que tenho que fazer', 'o que eu tenho que falar'
                        ],
                        duvida: [
                            'posso entrar sem crach√°', 'preciso falar algo', 'o que preciso fazer',
                            'como fa√ßo para entrar', 'posso passar', 'o que devo fazer',
                            'como funciona aqui', 'o que √© necess√°rio', 'preciso de ajuda',
                            'n√£o sei o que fazer', 'o que eu fa√ßo', 'como proceder'
                        ]
                    },
                    'en-US': {
                        matricula: [
                            'id', 'number', 'code', 'my id is', 'my number is', 'the number is',
                            'student id', 'id number', 'my code is'
                        ],
                        confusao: [
                            'i don\'t understand', 'i don\'t get it', 'what is this', 'what is',
                            'how does it work', 'what to do', 'i don\'t know', 'how to use',
                            'what should i say', 'i don\'t understand anything', 'what is this for',
                            'how do i use this', 'what am i supposed to do', 'i don\'t get how',
                            'what is this thing', 'how does this thing work', 'i don\'t know what to do',
                            'what is this here', 'how is this', 'i don\'t understand any of this',
                            'what am i supposed to say', 'how do i use this thing', 'i don\'t know how this works',
                            'what am i supposed to tell', 'how does this thing work', 'ah, i don\'t understand',
                            'i don\'t understand what i have to say', 'i don\'t understand what i have to do'
                        ],
                        duvida: [
                            'can i enter without badge', 'do i need to say something', 'what do i need to do',
                            'how do i enter', 'can i pass', 'what should i do', 'how does this work here',
                            'what is needed', 'i need help', 'i don\'t know what to do', 'what do i do',
                            'how to proceed'
                        ]
                    },
                    'es-ES': {
                        matricula: [
                            'matr√≠cula', 'n√∫mero', 'c√≥digo', 'mi matr√≠cula es', 'mi n√∫mero es',
                            'el n√∫mero es', 'el c√≥digo es', 'c√≥digo de estudiante'
                        ],
                        confusao: [
                            'no entiendo', 'no comprendo', 'no capto', 'qu√© es esto', 'qu√© es',
                            'c√≥mo funciona', 'qu√© hacer', 'no s√©', 'c√≥mo usar', 'qu√© debo decir',
                            'no comprendo nada', 'no entiendo nada', 'qu√© es para hacer', 'c√≥mo funciona esto',
                            'no s√© qu√© hacer', 'qu√© es esto aqu√≠', 'c√≥mo es que es', 'no entiendo nada de esto',
                            'qu√© es para hablar', 'c√≥mo usar esto', 'no s√© c√≥mo funciona', 'qu√© es para decir',
                            'c√≥mo es que funciona esto', 'ah, no entiendo', 'no entiendo qu√© tengo que decir',
                            'no entiendo qu√© tengo que hacer'
                        ],
                        duvida: [
                            'puedo entrar sin credencial', 'necesito decir algo', 'qu√© necesito hacer',
                            'c√≥mo hago para entrar', 'puedo pasar', 'qu√© debo hacer', 'c√≥mo funciona aqu√≠',
                            'qu√© es necesario', 'necesito ayuda', 'no s√© qu√© hacer', 'qu√© hago',
                            'c√≥mo proceder'
                        ]
                    }
                };

                const languageIntents = intents[language] || intents['pt-BR'];
                let bestIntent = { type: 'outros', confidence: 0 };

                // Verificar cada inten√ß√£o
                for (const [intentType, patterns] of Object.entries(languageIntents)) {
                    let matches = 0;
                    let totalWords = text.split(' ').length;

                    for (const pattern of patterns) {
                        if (text.includes(pattern)) {
                            matches++;
                        }
                    }

                    const confidence = matches / Math.max(1, totalWords);
                    
                    if (confidence > bestIntent.confidence) {
                        bestIntent = { type: intentType, confidence: confidence };
                    }
                }

                return bestIntent;
            }

            isConfusion(text, language) {
                const patterns = this.confusionPatterns[language] || this.confusionPatterns['pt-BR'];
                return patterns.some(pattern => text.includes(pattern));
            }

            extractMatricula(text, language) {
                const patterns = this.matriculaPatterns[language] || this.matriculaPatterns['pt-BR'];
                
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[1] || match[0];
                    }
                }
                
                return null;
            }

            async handleConfusion(text, language) {
                console.log('üö® Enviando alerta de confus√£o para Teams...');
                
                const now = new Date();
                const alertData = {
                    type: 'confusion',
                    text: text,
                    language: language,
                    timestamp: now.toISOString(),
                    priority: 'normal'
                };
                
                // Adicionar ao hist√≥rico de alertas
                this.alertHistory.push(alertData);
                
                // Limpar alertas antigos (mais de 5 minutos)
                this.alertHistory = this.alertHistory.filter(
                    alert => now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                // Verificar escalonamento
                const recentConfusions = this.alertHistory.filter(
                    alert => alert.type === 'confusion' && 
                    now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                if (recentConfusions.length >= this.alertThreshold) {
                    alertData.priority = recentConfusions.length >= this.highPriorityThreshold ? 'high' : 'medium';
                    console.log(`üö® ESCALONAMENTO: ${recentConfusions.length} confus√µes em 5 minutos - Prioridade: ${alertData.priority}`);
                }
                
                // Salvar √°udio de 5s no Supabase Storage
                const audioFileName = await this.saveAudioToSupabase('confusion', text, language);
                if (audioFileName) {
                    alertData.audioFile = audioFileName;
                }
                
                // Log de auditoria no Supabase
                this.logAuditEvent(alertData);
                
                // Enviar webhook com prioridade
                this.sendTeamsWebhook(alertData);
            }

            handleMatricula(matricula) {
                console.log(`üîç Buscando usu√°rio com matr√≠cula: ${matricula}`);
                this.searchUser(matricula);
            }

            handleMaxAttemptsReached() {
                console.log('üö® M√°ximo de tentativas atingido!');
                this.sendTeamsWebhook({
                    type: 'max_attempts',
                    attempts: this.attempts,
                    timestamp: new Date().toISOString()
                });
                this.attempts = 0;
            }

            async searchUser(matricula) {
                try {
                    const { data, error } = await supabase
                        .from('usuarios')
                        .select('*')
                        .eq('matricula', matricula)
                        .maybeSingle();

                    if (error) {
                        console.error('Erro ao buscar usu√°rio:', error);
                        return;
                    }

                    if (data) {
                        console.log('‚úÖ Usu√°rio encontrado:', data);
                        this.onUserFound(data);
                    } else {
                        console.log('‚ùå Usu√°rio n√£o encontrado');
                        this.onUserNotFound(matricula);
                    }
                } catch (error) {
                    console.error('Erro na busca:', error);
                }
            }

            sendTeamsWebhook(data) {
                const webhookUrl = 'https://empresasrandon.webhook.office.com/webhookb2/21c2c350-8575-4650-8022-9f8875009b17@812a6bd0-5829-4196-b2be-d0580b7bd0cb/IncomingWebhook/619eef161cee4793862ba686786a5e74/9430cacd-15e7-49b8-9de9-83a41c20c14d/V2FuComkGns1qwbtzubNP_dYSwYTfbWi0ougU3eh7YyUw1';
                
                // Cores baseadas na prioridade
                const priorityColors = {
                    'normal': '0076D7',
                    'medium': 'FF8C00',
                    'high': 'DC143C'
                };
                
                const priorityEmojis = {
                    'normal': 'üö®',
                    'medium': '‚ö†Ô∏è',
                    'high': 'üî•'
                };
                
                const color = priorityColors[data.priority] || priorityColors['normal'];
                const emoji = priorityEmojis[data.priority] || priorityEmojis['normal'];
                
                const message = {
                    "@type": "MessageCard",
                    "@context": "http://schema.org/extensions",
                    "themeColor": color,
                    "summary": `Alerta do Sistema de Voz - ${data.priority.toUpperCase()}`,
                    "sections": [{
                        "activityTitle": `${emoji} Alerta do Sistema de Reconhecimento de Voz`,
                        "activitySubtitle": `Tipo: ${data.type} | Prioridade: ${data.priority.toUpperCase()}`,
                        "facts": [
                            { "name": "Timestamp", "value": data.timestamp },
                            { "name": "Tentativas", "value": data.attempts || 'N/A' },
                            { "name": "Texto", "value": data.text || 'N/A' },
                            { "name": "Idioma", "value": data.language || 'N/A' },
                            { "name": "Prioridade", "value": data.priority.toUpperCase() }
                        ]
                    }]
                };

                fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(message)
                }).then(response => {
                    if (response.ok) {
                        console.log('‚úÖ Webhook Teams enviado com sucesso');
                        // Log status de sucesso
                        this.logAuditEvent({
                            ...data,
                            type: 'webhook_status',
                            status: 'teams_ok',
                            message: 'Webhook Teams enviado com sucesso'
                        });
                    } else {
                        console.error('Erro ao enviar webhook Teams:', response.status);
                        // Fallback para email se Teams falhar
                        this.sendEmailFallback(data);
                    }
                }).catch(error => {
                    console.error('Erro ao enviar webhook:', error);
                    // Fallback para email se Teams falhar
                    this.sendEmailFallback(data);
                });
            }

            // Fallback para email se Teams falhar
            sendEmailFallback(data) {
                console.log('üìß Enviando fallback por email...');
                // Aqui voc√™ pode implementar envio de email via API
                // Por exemplo, usando SendGrid, AWS SES, etc.
                this.logAuditEvent({
                    ...data,
                    type: 'email_fallback',
                    message: 'Teams webhook falhou, enviado por email'
                });
            }

            // Sistema de captura de √°udio
            async setupAudioRecording() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.audioSampleRate
                    });
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: this.audioSampleRate,
                            channelCount: this.audioChannels,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    const processor = this.audioContext.createScriptProcessor(4096, this.audioChannels, this.audioChannels);
                    
                    processor.onaudioprocess = (event) => {
                        if (this.isRecording) {
                            const inputData = event.inputBuffer.getChannelData(0);
                            this.audioBuffer.push(new Float32Array(inputData));
                            
                            // Manter apenas os √∫ltimos 5 segundos
                            const maxSamples = this.audioSampleRate * this.audioBufferSize;
                            if (this.audioBuffer.length * 4096 > maxSamples) {
                                this.audioBuffer.shift();
                            }
                        }
                    };
                    
                    source.connect(processor);
                    processor.connect(this.audioContext.destination);
                    
                    console.log('üéôÔ∏è Sistema de grava√ß√£o de √°udio configurado');
                } catch (error) {
                    console.error('Erro ao configurar grava√ß√£o de √°udio:', error);
                }
            }

            startAudioRecording() {
                this.isRecording = true;
                this.audioBuffer = [];
                console.log('üî¥ Iniciando grava√ß√£o de √°udio...');
            }

            stopAudioRecording() {
                this.isRecording = false;
                console.log('‚èπÔ∏è Parando grava√ß√£o de √°udio...');
            }

            async saveAudioToSupabase(eventType, text, language) {
                if (this.audioBuffer.length === 0) {
                    console.log('‚ö†Ô∏è Nenhum √°udio para salvar');
                    return null;
                }

                try {
                    // Converter buffer para WAV
                    const wavBlob = this.audioToWav(this.audioBuffer);
                    
                    // Gerar nome √∫nico para o arquivo
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const fileName = `audio_${eventType}_${timestamp}.wav`;
                    
                    // Upload para Supabase Storage
                    const { data, error } = await supabase.storage
                        .from('voice-audio')
                        .upload(fileName, wavBlob, {
                            contentType: 'audio/wav',
                            cacheControl: '3600'
                        });

                    if (error) {
                        console.error('Erro ao fazer upload do √°udio:', error);
                        return null;
                    }

                    console.log('‚úÖ √Åudio salvo no Supabase Storage:', fileName);
                    return fileName;
                } catch (error) {
                    console.error('Erro ao salvar √°udio:', error);
                    return null;
                }
            }

            audioToWav(audioBuffer) {
                const length = audioBuffer.reduce((acc, buffer) => acc + buffer.length, 0);
                const arrayBuffer = new ArrayBuffer(44 + length * 2);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, this.audioChannels, true);
                view.setUint32(24, this.audioSampleRate, true);
                view.setUint32(28, this.audioSampleRate * this.audioChannels * 2, true);
                view.setUint16(32, this.audioChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 2, true);
                
                // Audio data
                let offset = 44;
                for (const buffer of audioBuffer) {
                    for (let i = 0; i < buffer.length; i++) {
                        const sample = Math.max(-1, Math.min(1, buffer[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            startListening() {
                if (this.recognition && !this.isListening) {
                    this.attempts = 0;
                    this.recognition.start();
                    this.startAudioRecording();
                }
            }

            stopListening() {
                if (this.recognition && this.isListening) {
                    this.recognition.stop();
                    this.stopAudioRecording();
                }
            }

            // Callbacks para integra√ß√£o com ondas sonoras
            onVoiceStart() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.startListening();
                }
            }

            onVoiceEnd() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.stopListening();
                }
            }

            onInterimResult(text) {
                if (window.sonicWaveform) {
                    // Simular intensidade baseada no comprimento do texto
                    const intensity = Math.min(1, text.length / 50);
                    window.sonicWaveform.updateVoiceData(intensity, 1, 1);
                }
            }

            // Web Audio API para an√°lise de √°udio em tempo real
            setupAudioAnalysis() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (!this.analyser) {
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.analyser.smoothingTimeConstant = 0.8;
                }
                
                if (!this.microphone) {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            this.microphone = this.audioContext.createMediaStreamSource(stream);
                            this.microphone.connect(this.analyser);
                            this.startAudioAnalysis();
                        })
                        .catch(error => console.error('Erro ao acessar microfone:', error));
                }
            }

            startAudioAnalysis() {
                if (!this.analyser) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const timeDomainData = new Float32Array(this.analyser.fftSize);
                
                // VAD (Voice Activity Detection) - detectar se √© voz humana
                let voiceThreshold = 0.01; // Threshold para detectar voz
                let silenceCounter = 0;
                let maxSilenceFrames = 30; // 30 frames de sil√™ncio = parar
                
                const analyze = () => {
                    if (this.isListening) {
                        this.analyser.getByteFrequencyData(dataArray);
                        this.analyser.getFloatTimeDomainData(timeDomainData);
                        
                        // Calcular RMS (Root Mean Square) para intensidade
                        const rms = Math.sqrt(dataArray.reduce((sum, value) => sum + value * value, 0) / dataArray.length) / 255;
                        
                        // VAD - detectar se √© voz humana
                        const isVoice = this.detectVoice(dataArray, timeDomainData);
                        
                        if (isVoice) {
                            silenceCounter = 0;
                            
                            // FFT - An√°lise de frequ√™ncia real
                            const frequencyData = this.analyzeFrequencySpectrum(dataArray);
                            
                            // Atualizar ondas sonoras com dados reais de voz
                            if (window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(
                                    frequencyData.intensity,
                                    frequencyData.dominantFreq,
                                    frequencyData.amplitude
                                );
                            }
                        } else {
                            silenceCounter++;
                            
                            // Se muito sil√™ncio, reduzir intensidade das ondas
                            if (silenceCounter > maxSilenceFrames && window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(0.1, 0.5, 0.1);
                            }
                        }
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }

            // Detectar se √© voz humana (VAD)
            detectVoice(frequencyData, timeDomainData) {
                // Calcular energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                
                // Calcular energia em frequ√™ncias de voz (300Hz - 3400Hz)
                const voiceStart = Math.floor(300 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnd = Math.floor(3400 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnergy = frequencyData.slice(voiceStart, voiceEnd).reduce((sum, value) => sum + value, 0) / (voiceEnd - voiceStart);
                
                // Calcular energia em frequ√™ncias de ru√≠do (0-300Hz, 3400Hz+)
                const noiseEnergy = (frequencyData.slice(0, voiceStart).reduce((sum, value) => sum + value, 0) + 
                                   frequencyData.slice(voiceEnd).reduce((sum, value) => sum + value, 0)) / 
                                   (voiceStart + frequencyData.length - voiceEnd);
                
                // Detectar voz se energia de voz > ru√≠do e total > threshold
                const voiceRatio = voiceEnergy / (noiseEnergy + 0.001);
                const isVoice = totalEnergy > this.voiceThreshold && voiceRatio > 1.5;
                
                return isVoice;
            }

            // An√°lise de espectro de frequ√™ncia (FFT)
            analyzeFrequencySpectrum(frequencyData) {
                // Encontrar frequ√™ncia dominante
                let maxValue = 0;
                let maxIndex = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                // Converter √≠ndice para frequ√™ncia real
                const dominantFreq = (maxIndex * this.analyser.sampleRate) / (2 * frequencyData.length);
                
                // Calcular intensidade normalizada
                const intensity = maxValue / 255;
                
                // Calcular amplitude baseada na energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                const amplitude = Math.min(2, totalEnergy / 100);
                
                // Analisar formantes (caracter√≠sticas da voz)
                const formants = this.analyzeFormants(frequencyData);
                
                return {
                    intensity: intensity,
                    dominantFreq: Math.min(3, dominantFreq / 1000), // Normalizar para 0-3
                    amplitude: amplitude,
                    formants: formants
                };
            }

            // An√°lise de formantes (caracter√≠sticas √∫nicas da voz)
            analyzeFormants(frequencyData) {
                const formants = [];
                const sampleRate = this.analyser.sampleRate;
                const nyquist = sampleRate / 2;
                
                // Procurar picos de energia (formantes)
                for (let i = 1; i < frequencyData.length - 1; i++) {
                    if (frequencyData[i] > frequencyData[i-1] && 
                        frequencyData[i] > frequencyData[i+1] && 
                        frequencyData[i] > 50) { // Threshold m√≠nimo
                        
                        const freq = (i * nyquist) / frequencyData.length;
                        if (freq > 200 && freq < 4000) { // Range de formantes
                            formants.push({
                                frequency: freq,
                                amplitude: frequencyData[i] / 255
                            });
                        }
                    }
                }
                
                return formants;
            }

            onUserFound(user) {
                console.log('üéâ Usu√°rio validado com sucesso!');
                // Redirecionar para tela de sucesso
                setTimeout(() => {
                    window.location.href = 'tela_depois_cracha.html';
                }, 1000);
            }

            onUserNotFound(matricula) {
                console.log('‚ùå Matr√≠cula n√£o encontrada no sistema');
                this.attempts++;
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // Log de auditoria no Supabase
            async logAuditEvent(eventData) {
                try {
                    const { error } = await supabase
                        .from('audit_logs')
                        .insert([{
                            event_type: eventData.type,
                            text: eventData.text,
                            language: eventData.language,
                            attempts: eventData.attempts || 0,
                            timestamp: eventData.timestamp,
                            created_at: new Date().toISOString()
                        }]);

                    if (error) {
                        console.error('Erro ao salvar log de auditoria:', error);
                    } else {
                        console.log('‚úÖ Log de auditoria salvo com sucesso');
                    }
                } catch (error) {
                    console.error('Erro na fun√ß√£o de log:', error);
                }
            }
        }

        // Sonic Waveform Canvas Class
        class SonicWaveformCanvas {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.animationFrameId = null;
                this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };
                this.time = 0;
                
                // Voice detection properties
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.draw();
                this.setupEventListeners();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            draw() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const lineCount = 60;
                const segmentCount = 80;
                const height = this.canvas.height / 2;
                
                // Voice detection effects
                const voiceEffect = this.isListening ? this.voiceIntensity : 0;
                const voiceAmplitude = this.isListening ? this.voiceAmplitude : 1;
                const voiceFreq = this.isListening ? this.voiceFrequency : 1;
                
                for (let i = 0; i < lineCount; i++) {
                    this.ctx.beginPath();
                    const progress = i / lineCount;
                    const colorIntensity = Math.sin(progress * Math.PI);
                    
                    // Voice affects color intensity
                    const voiceColorIntensity = colorIntensity * (1 + voiceEffect * 0.5);
                    this.ctx.strokeStyle = `rgba(0, 255, 192, ${voiceColorIntensity * 0.5})`;
                    this.ctx.lineWidth = 1.5 + (voiceEffect * 2);

                    for (let j = 0; j < segmentCount + 1; j++) {
                        const x = (j / segmentCount) * this.canvas.width;
                        
                        // Mouse influence (desabilitado para touch screen)
                        const distToMouse = Math.hypot(x - this.mouse.x, (height) - this.mouse.y);
                        const mouseEffect = Math.max(0, 1 - distToMouse / 400);

                        // Wave calculation with voice effects
                        const noise = Math.sin(j * 0.1 + this.time + i * 0.2) * 20;
                        const spike = Math.cos(j * 0.2 + this.time + i * 0.1) * Math.sin(j * 0.05 + this.time) * 50;
                        
                        // Voice detection adds dynamic effects
                        const voiceNoise = this.isListening ? 
                            Math.sin(j * voiceFreq * 0.1 + this.time + i * 0.2) * 30 * voiceEffect : 0;
                        const voiceSpike = this.isListening ? 
                            Math.cos(j * voiceFreq * 0.2 + this.time + i * 0.1) * Math.sin(j * voiceFreq * 0.05 + this.time) * 80 * voiceEffect : 0;
                        
                        const y = height + noise + spike * (1 + mouseEffect * 2) + 
                                 voiceNoise + voiceSpike * voiceAmplitude;
                        
                        if (j === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                }

                this.time += 0.02;
                this.animationFrameId = requestAnimationFrame(() => this.draw());
            }

            setupEventListeners() {
                const handleResize = () => {
                    this.resizeCanvas();
                };

                window.addEventListener('resize', handleResize);
                
                // Cleanup function
                this.cleanup = () => {
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                    }
                    window.removeEventListener('resize', handleResize);
                };
            }

            resize() {
                this.resizeCanvas();
            }

            destroy() {
                if (this.cleanup) {
                    this.cleanup();
                }
            }

            // Voice detection methods
            startListening() {
                this.isListening = true;
                this.voiceIntensity = 0.5;
                this.voiceFrequency = 1;
                this.voiceAmplitude = 1;
            }

            stopListening() {
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
            }

            updateVoiceData(intensity, frequency, amplitude) {
                this.voiceIntensity = Math.min(1, Math.max(0, intensity));
                this.voiceFrequency = Math.min(3, Math.max(0.5, frequency));
                this.voiceAmplitude = Math.min(2, Math.max(0.5, amplitude));
            }

            // Simulate voice detection for testing
            simulateVoiceDetection() {
                if (this.isListening) {
                    // Simulate random voice data
                    const intensity = 0.3 + Math.random() * 0.7;
                    const frequency = 0.8 + Math.random() * 1.4;
                    const amplitude = 0.8 + Math.random() * 1.2;
                    
                    this.updateVoiceData(intensity, frequency, amplitude);
                }
            }
        }

        // Sistema de Scanner de C√≥digo de Barras
        class BarcodeScanner {
            constructor() {
                this.isScanning = false;
                this.currentStream = null;
                this.supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
                this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
                this.supabase = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'environment'
                        } 
                    });
                    
                    this.currentStream = stream;
                    const video = document.getElementById('scannerVideo');
                    video.srcObject = stream;
                    
                    video.onloadedmetadata = () => {
                        video.play();
                        // Aguardar o v√≠deo estar reproduzindo antes de iniciar o scanner
                        video.onplaying = () => {
                            console.log('V√≠deo est√° reproduzindo, iniciando scanner...');
                            setTimeout(() => {
                                this.startScanner();
                            }, 1000); // Aguardar 1 segundo para garantir estabilidade
                        };
                    };
                    
                } catch (error) {
                    console.error('Erro ao acessar webcam:', error);
                    this.showError('Webcam n√£o dispon√≠vel');
                }
            }

            startScanner() {
                if (this.isScanning) return;
                
                console.log('Iniciando scanner de c√≥digo de barras...');
                this.isScanning = true;
                const videoElement = document.getElementById('scannerVideo');
                
                if (!videoElement) {
                    console.error('Elemento de v√≠deo n√£o encontrado');
                    this.showError('Elemento de v√≠deo n√£o encontrado');
                    return;
                }
                
                console.log('Elemento de v√≠deo encontrado:', videoElement);
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: videoElement,
                        constraints: {
                            width: 640,
                            height: 480,
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader",
                            "ean_reader",
                            "code_39_reader",
                            "ean_8_reader",
                            "upc_reader"
                        ],
                        debug: {
                            drawBoundingBox: true,
                            showFrequency: false,
                            showDetectedRegion: false,
                            showSkeleton: false,
                            showLabels: false,
                            showPatch: false,
                            showBoxes: false
                        }
                    },
                    locate: true,
                    locator: {
                        patchSize: "large",
                        halfSample: false
                    },
                    numOfWorkers: 2,
                    frequency: 10,
                    debug: false
                }, (err) => {
                    if (err) {
                        console.error('Erro ao inicializar scanner:', err);
                        this.showError('Erro ao inicializar scanner');
                        return;
                    }
                    
                    console.log('Scanner inicializado com sucesso');
                    Quagga.start();
                    this.showQualityIndicator();
                    
                    // Adicionar listener para debug de processamento
                    let frameCount = 0;
                    Quagga.onProcessed((result) => {
                        frameCount++;
                        if (frameCount % 30 === 0) {
                            console.log('üîÑ Processando frame...', frameCount);
                        }
                        if (result && result.codeResult) {
                            console.log('üéØ C√≥digo encontrado no processamento:', result.codeResult);
                        }
                    });
                });
                
                Quagga.onDetected((result) => {
                    console.log('üéØ C√≥digo detectado pelo Quagga:', result);
                    if (result && result.codeResult) {
                        const code = result.codeResult.code;
                        const confidence = result.codeResult.confidence;
                        console.log('‚úÖ C√≥digo v√°lido detectado:', code, 'Confian√ßa:', confidence);
                        
                        Quagga.stop();
                        this.isScanning = false;
                        this.searchUser(code);
                    } else {
                        console.log('‚ùå Resultado inv√°lido:', result);
                    }
                });
            }

            async searchUser(codigoBarras) {
                try {
                    this.showFeedback('Verificando acesso...', 'info');
                    
                    const { data, error } = await this.supabase
                        .from('usuarios')
                        .select('nome_completo, empresa')
                        .eq('codigo_barras', codigoBarras)
                        .maybeSingle();
                    
                    if (error) {
                        console.error('Erro na consulta:', error);
                        this.showFeedback('Erro na consulta do banco de dados', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    } else if (data) {
                        console.log('Usu√°rio encontrado:', data);
                        this.showFeedback(`Acesso autorizado - ${data.nome_completo}!`, 'success');
                        setTimeout(() => {
                            this.redirectToWelcome(data.nome_completo);
                        }, 1500);
                    } else {
                        console.log('Usu√°rio n√£o encontrado');
                        this.showFeedback('Acesso negado - Usu√°rio n√£o cadastrado', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    }
                    
                } catch (error) {
                    console.error('Erro na busca:', error);
                    this.showFeedback('Erro interno do sistema', 'error');
                    setTimeout(() => this.restartScanner(), 3000);
                }
            }

            showFeedback(message, type) {
                const feedback = document.createElement('div');
                feedback.className = `fixed top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg text-white font-semibold z-50 ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    'bg-blue-500'
                }`;
                feedback.textContent = message;
                
                document.body.appendChild(feedback);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.remove();
                    }
                }, 3000);
            }

            redirectToWelcome(nomeCompleto) {
                const primeiroNome = nomeCompleto.split(' ')[0];
                localStorage.setItem('usuarioNome', primeiroNome);
                window.location.href = 'tela_depois_cracha.html';
            }

            restartScanner() {
                if (this.isScanning) return;
                
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner j√° estava parado');
                }
                
                setTimeout(() => {
                    this.startScanner();
                }, 1000);
            }

            showQualityIndicator() {
                const indicator = document.getElementById('qualityIndicator');
                if (indicator) {
                    indicator.style.display = 'block';
                }
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                if (errorDiv) {
                    errorDiv.style.display = 'flex';
                    errorDiv.querySelector('p').textContent = message;
                }
            }

            stop() {
                this.isScanning = false;
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner j√° estava parado');
                }
                
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
            }
        }

        // YOLOv11 Person Detection Class (ONNX)
        class YOLOv11Detector {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.personCount = 0;
                this.personRequired = 2; // Detec√ß√µes necess√°rias
                this.statusElement = document.getElementById('statusText');
                this.redirectDelay = 2000; // 2 segundos antes de redirecionar
                this.redirectTimeout = null;
                this.lastDetectionTime = 0;
                this.detectionInterval = 150; // Detectar a cada 150ms
                this.session = null;
                this.inputShape = [1, 3, 640, 640]; // YOLOv11 input shape
                this.config = {
                    minConfidence: 0.5, // 50% de confian√ßa m√≠nima
                    nmsThreshold: 0.4, // Non-Maximum Suppression
                    maxDetections: 5, // M√°ximo 5 pessoas
                    realTime: true // Tempo real
                };
                this.classNames = ['person']; // Apenas detec√ß√£o de pessoas
            }

            async init() {
                try {
                    // Solicitar acesso √† c√¢mera (oculta)
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user' // C√¢mera frontal
                        } 
                    });

                    // Criar elementos ocultos para detec√ß√£o
                    this.video = document.createElement('video');
                    this.canvas = document.createElement('canvas');
                    this.ctx = this.canvas.getContext('2d');

                    // Configurar v√≠deo (oculto)
                    this.video.srcObject = stream;
                    this.video.play();
                    this.video.style.display = 'none';
                    document.body.appendChild(this.video);

                    // Configurar canvas (oculto)
                    this.canvas.width = 200;
                    this.canvas.height = 150;
                    this.canvas.style.display = 'none';
                    document.body.appendChild(this.canvas);

                    // Aguardar v√≠deo carregar
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Inicializar detec√ß√£o de pessoa
                    await this.initYOLOv11();
                    console.log('Detec√ß√£o de pessoa ativa (oculta)');

                } catch (error) {
                    console.error('Erro ao acessar c√¢mera:', error);
                    console.log('Detec√ß√£o de pessoa desabilitada');
                }
            }

            async initYOLOv11() {
                try {
                    // Usar apenas COCO-SSD para evitar problemas de CORS
                    console.log('Carregando COCO-SSD para detec√ß√£o de pessoas...');
                    
                    this.model = await cocoSsd.load({
                        base: 'mobilenet_v2',
                        version: 'lite_mobilenet_v2'
                    });
                    console.log('COCO-SSD carregado com sucesso');
                    this.updateStatus('COCO-SSD ativo - Detectando pessoas...');
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Erro ao carregar COCO-SSD:', error);
                    this.updateStatus('Erro na inicializa√ß√£o - Clique para continuar');
                }
            }

            startDetection() {
                if (!this.video || !this.model) {
                    console.error('V√≠deo ou modelo n√£o inicializado');
                    return;
                }

                const detectPersons = async () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        const now = Date.now();
                        if (now - this.lastDetectionTime > this.detectionInterval) {
                            try {
                                // Usar apenas COCO-SSD
                                const predictions = await this.model.detect(this.video);
                                this.onPersonDetectionResults(predictions);
                                this.lastDetectionTime = now;
                            } catch (error) {
                                console.error('Erro na detec√ß√£o:', error);
                            }
                        }
                    }

                    if (this.isDetecting) {
                        requestAnimationFrame(detectPersons);
                    }
                };

                this.isDetecting = true;
                console.log('Iniciando detec√ß√£o de pessoas...');
                detectPersons();
            }


            onPersonDetectionResults(predictions) {
                // Limpar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Filtrar apenas detec√ß√µes de pessoas com alta confian√ßa
                const persons = predictions.filter(prediction => 
                    prediction.class === 'person' && 
                    prediction.score > this.config.minConfidence
                );

                if (persons.length > 0) {
                    console.log(`Detectou ${persons.length} pessoa(s)`);
                    
                    // Desenhar informa√ß√µes das pessoas
                    this.drawPersonInformation(persons);

                    // Incrementar contador de pessoas
                    this.personCount++;
                    this.updateStatus(`Pessoa detectada! (${this.personCount}/${this.personRequired})`);
                    
                    if (this.personCount >= this.personRequired) {
                        this.handlePersonDetected();
                    }
                } else {
                    this.personCount = Math.max(0, this.personCount - 1);
                    this.updateStatus('Detectando pessoas...');
                }
            }

            drawPersonInformation(persons) {
                persons.forEach((person, index) => {
                    const { x, y, width, height } = person.bbox;
                    
                    // Escalar coordenadas para o canvas da preview
                    const scaleX = this.canvas.width / this.video.videoWidth;
                    const scaleY = this.canvas.height / this.video.videoHeight;
                    
                    const scaledX = x * scaleX;
                    const scaledY = y * scaleY;
                    const scaledWidth = width * scaleX;
                    const scaledHeight = height * scaleY;

                    // Cores YOLOv11
                    const colors = ['#00FF88', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const color = colors[index % colors.length];
                    const borderColor = color;

                    // Desenhar bounding box da pessoa
                    this.ctx.strokeStyle = borderColor;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);

                    // Informa√ß√µes da pessoa
                    const info = [];
                    info.push(`Pessoa: ${(person.score * 100).toFixed(1)}%`);
                    
                    const labelText = info.join(' | ');
                    const labelWidth = this.ctx.measureText(labelText).width + 10;
                    const labelHeight = 20;
                    
                    // Fundo do label
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY - labelHeight, labelWidth, labelHeight);
                    
                    // Texto do label
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.fillText(labelText, scaledX + 5, scaledY - 5);

                    // Indicador de confian√ßa
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY + scaledHeight + 2, scaledWidth * person.score, 3);
                });

                // Barra de progresso geral
                const progressWidth = this.canvas.width - 40;
                const progressHeight = 6;
                const progressX = 20;
                const progressY = this.canvas.height - 20;
                
                // Fundo da barra
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Barra de progresso
                const progress = this.personCount / this.personRequired;
                this.ctx.fillStyle = '#00FF88';
                this.ctx.fillRect(progressX, progressY, progressWidth * progress, progressHeight);
            }

            handlePersonDetected() {
                this.updateStatus('Pessoa detectada! Aguardando 5 segundos...');
                this.isDetecting = false;

                // Parar a c√¢mera
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                // Contador regressivo de 5 segundos
                let countdown = 5;
                const countdownInterval = setInterval(() => {
                    this.updateStatus(`Pessoa detectada! Redirecionando em ${countdown} segundos...`);
                    countdown--;
                    
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.updateStatus('Redirecionando para tela do cracha...');
                        
                        // Alternar para scanner ap√≥s 5 segundos
                        setTimeout(() => {
                            switchToScanner();
                        }, 1000); // 1 segundo adicional para mostrar a mensagem final
                    }
                }, 1000);

            }

            updateStatus(message) {
                // Status removido - detec√ß√£o oculta
                console.log('Status:', message);
            }

            // M√©todo para otimizar performance do YOLOv11
            optimizeForYOLOv11() {
                // Ajustar configura√ß√µes baseado na performance
                const fps = 1000 / this.detectionInterval;
                if (fps < 8) {
                    this.detectionInterval = 150; // Reduzir frequ√™ncia se muito lento
                    this.config.minConfidence = 0.8; // Aumentar threshold
                } else if (fps > 12) {
                    this.detectionInterval = 80; // Aumentar frequ√™ncia se muito r√°pido
                    this.config.minConfidence = 0.6; // Diminuir threshold
                }
            }


            stop() {
                this.isDetecting = false;
                if (this.redirectTimeout) {
                    clearTimeout(this.redirectTimeout);
                }
                // Limpar qualquer countdown ativo
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                // Remover elementos criados dinamicamente
                if (this.video && this.video.parentNode) {
                    this.video.parentNode.removeChild(this.video);
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
            }
        }

        // Inicializar scanner de c√≥digo de barras
        function initBarcodeScanner() {
            if (window.barcodeScanner) {
                window.barcodeScanner.init();
            } else {
                window.barcodeScanner = new BarcodeScanner();
                window.barcodeScanner.init();
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('vortexCanvas');
            const sonicWaveform = new SonicWaveformCanvas(canvas);
            window.sonicWaveform = sonicWaveform;

            // Inicializar detector YOLOv11 de pessoas
            const yoloDetector = new YOLOv11Detector();
            yoloDetector.init();

            // Inicializar sistema de reconhecimento de voz
            const voiceSystem = new VoiceRecognitionSystem();
            window.voiceSystem = voiceSystem;

            // Configurar an√°lise de √°udio
            voiceSystem.setupAudioAnalysis();
            
            // Configurar grava√ß√£o de √°udio
            voiceSystem.setupAudioRecording();

            // Bot√£o para iniciar sistema de voz na tela de scanner
            const voiceStartBtn = document.getElementById('voiceStartBtn');
            let isListening = false;
            
            voiceStartBtn.addEventListener('click', () => {
                if (!isListening) {
                    voiceSystem.startListening();
                    voiceStartBtn.textContent = 'üîá Parar Reconhecimento';
                    voiceStartBtn.classList.remove('bg-teal-500', 'hover:bg-teal-600');
                    voiceStartBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                    isListening = true;
                } else {
                    voiceSystem.stopListening();
                    voiceStartBtn.textContent = 'üé§ Iniciar Reconhecimento de Voz';
                    voiceStartBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    voiceStartBtn.classList.add('bg-teal-500', 'hover:bg-teal-600');
                    isListening = false;
                }
            });

            // Inicializar scanner de c√≥digo de barras
            window.barcodeScanner = new BarcodeScanner();

            // Handle window resize
            window.addEventListener('resize', () => {
                sonicWaveform.resize();
            });

            // Limpar recursos ao sair da p√°gina
            window.addEventListener('beforeunload', () => {
                sonicWaveform.destroy();
                yoloDetector.stop();
                if (window.barcodeScanner) {
                    window.barcodeScanner.stop();
                }
            });
        });

        // Sistema de altern√¢ncia entre telas
        let currentScreen = 'idle';
        let scannerInitialized = false;
        let idleTimeout = null;
        const IDLE_TIMEOUT = 30000; // 30 segundos

        function switchToScanner() {
            if (currentScreen === 'scanner') return;
            
            currentScreen = 'scanner';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Ocultar tela de descanso
            document.getElementById('idleScreen').style.display = 'none';
            
            // Mostrar tela de scanner com anima√ß√£o
            const scannerScreen = document.getElementById('scannerScreen');
            scannerScreen.style.display = 'flex';
            
            // Ativar anima√ß√£o
            setTimeout(() => {
                scannerScreen.classList.add('active');
            }, 50);
            
            // Inicializar scanner se ainda n√£o foi inicializado
            if (!scannerInitialized) {
                initBarcodeScanner();
                scannerInitialized = true;
            }
            
            // Configurar timeout para voltar √† tela de descanso
            idleTimeout = setTimeout(() => {
                switchToIdle();
            }, IDLE_TIMEOUT);
        }

        function switchToIdle() {
            if (currentScreen === 'idle') return;
            
            currentScreen = 'idle';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Ocultar tela de scanner
            const scannerScreen = document.getElementById('scannerScreen');
            scannerScreen.classList.remove('active');
            
            setTimeout(() => {
                scannerScreen.style.display = 'none';
                document.getElementById('idleScreen').style.display = 'flex';
            }, 800);
            
            // Parar scanner
            if (window.barcodeScanner) {
                window.barcodeScanner.stop();
            }
        }

        // Alternar para tela de scanner ao clicar
        document.addEventListener('click', function() {
            switchToScanner();
        });

        // Alternar para tela de scanner ao tocar (mobile)
        document.addEventListener('touchstart', function() {
            switchToScanner();
        });

        // Prevenir comportamento padr√£o de toque
        document.addEventListener('touchend', function(e) {
            e.preventDefault();
        });

    </script>
</body>
</html>
