<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Innovate Hub - Sistema de RecepÃ§Ã£o</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            cursor: pointer;
        }

        .vortex-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .vortex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }

         .logo-conexo {
             max-width: 500px;
             height: auto;
             margin-bottom: 2rem;
             filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.7));
             animation: fadeInUp 2s ease-out;
         }

        .hub-text {
            color: #ffffff;
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            margin-top: 12rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            animation: fadeInUp 2s ease-out 0.3s both;
        }

        .logo-randoncorp {
            max-width: 250px;
            height: auto;
            margin-top: 0.5rem;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
            animation: fadeInUp 2s ease-out 0.6s both;
        }


        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        /* Estilos da Tela de Scanner */
        .scanner-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s ease-in-out;
        }

        .scanner-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        .scanner-container {
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .scanner-icon {
            margin-bottom: 2rem;
        }

        .scanner-icon .material-symbols-outlined {
            font-size: 100px;
            color: #39E079;
        }

        .scanner-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #00f0ff, #7f00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .scanner-subtitle {
            font-size: 1.125rem;
            color: #8888a0;
            margin-bottom: 3rem;
        }


        .scanner-help {
            font-size: 0.875rem;
            color: #8888a0;
        }

        /* Face Detection Styles */
        .face-detection-container {
            position: relative;
            width: 320px;
            height: 400px;
            margin: 2rem auto;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 192, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 192, 0.2);
        }

        .face-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .face-outline {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 250px;
            border: 3px solid #00FFC0;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 194, 0.5);
            pointer-events: none;
            animation: facePulse 2s infinite;
        }

        .face-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
        }

        .detection-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: #00FFC0;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .detection-status .material-symbols-outlined {
            font-size: 2rem;
            animation: searchPulse 1.5s infinite;
        }

        @keyframes facePulse {
            0%, 100% { 
                border-color: #00FFC0;
                box-shadow: 0 0 20px rgba(0, 255, 194, 0.5);
            }
            50% { 
                border-color: #00FF80;
                box-shadow: 0 0 30px rgba(0, 255, 194, 0.8);
            }
        }

        @keyframes searchPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.7;
            }
        }



        @keyframes scanLine {
            0% { transform: translateY(0px); opacity: 1; }
            50% { transform: translateY(192px); opacity: 1; }
            100% { transform: translateY(0px); opacity: 1; }
        }

        @keyframes holographic-pulse {
            0% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
            50% { box-shadow: 0 0 20px #7f00ff, 0 0 40px #7f00ff, inset 0 0 20px #7f00ff; }
            100% { box-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff, inset 0 0 10px #00f0ff; }
        }
    </style>
</head>
<body>
    <div class="vortex-container">
        <canvas id="vortexCanvas" class="vortex-canvas"></canvas>
                <!-- Tela de Descanso -->
                <div class="content" id="idleScreen">
                    <img src="conexo-logo.png" alt="Conexo Logo" class="logo-conexo">
                    <div class="hub-text">Hub de inovaÃ§Ã£o da</div>
                    <img src="randoncorp-png.png" alt="RandonCorp Logo" class="logo-randoncorp">
                </div>

        <!-- Tela de Reconhecimento Facial -->
        <div class="scanner-content" id="scannerScreen" style="display: none;">
            <div class="scanner-container">
                <div class="scanner-icon">
                    <span class="material-symbols-outlined">face</span>
                </div>
                <h1 class="scanner-title">Reconhecimento Facial</h1>
                <p class="scanner-subtitle">Posicione seu rosto na Ã¡rea demarcada</p>
                
                <div class="face-detection-container">
                    <div class="face-outline"></div>
                    <video id="faceVideo" class="face-video" autoplay muted playsinline></video>
                    <div class="face-overlay">
                        <div class="detection-status" id="detectionStatus">
                            <span class="material-symbols-outlined">search</span>
                            <span>Detectando rosto...</span>
                        </div>
                        
                        <div class="mt-4 text-center">
                            <button id="restartButton" onclick="restartFacialRecognition()" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded opacity-0 transition-opacity duration-300">
                                <span class="material-symbols-outlined mr-2">refresh</span>
                                Reiniciar DetecÃ§Ã£o
                            </button>
                        </div>
                    </div>
                </div>
                
                <p class="scanner-help">Sistema de reconhecimento facial ativo.</p>
            </div>
        </div>
        
    </div>

    <!-- DependÃªncias -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <script src="supabase_config.js"></script>

    <script>
        // Inicializar Supabase globalmente (apenas uma instÃ¢ncia)
        if (!window.supabaseClient) {
            const supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
            const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
            window.supabaseClient = window.supabase.createClient(supabaseUrl, supabaseKey);
        }
        
        // Inicializar SupabaseManager (apenas uma instÃ¢ncia)
        if (!window.supabaseManager) {
            window.supabaseManager = new SupabaseManager();
        }

        // Sistema de Reconhecimento Facial com CompreFace
        class CompreFaceDetector {
            constructor() {
                this.apiKey = 'c3e84a46-1a08-4913-8330-31818f0c0e06';
                this.baseUrl = 'http://localhost:8000/api/v1'; // URL local do CompreFace
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.detectionInterval = null;
                this.faceDetected = false;
                this.recognitionThreshold = 0.6;
                this.useSimulatedMode = false;
                this.subjectId = null; // ID do usuÃ¡rio reconhecido
            }

            async init() {
                try {
                    console.log('ðŸŽ­ Inicializando sistema de reconhecimento facial...');
                    
                    // Verificar se CompreFace estÃ¡ disponÃ­vel
                    const isCompreFaceAvailable = await this.checkCompreFaceStatus();
                    
                    if (!isCompreFaceAvailable) {
                        console.log('âš ï¸ CompreFace nÃ£o disponÃ­vel, usando modo simulado');
                        this.useSimulatedMode = true;
                        this.updateStatus('Modo simulado ativo - CompreFace nÃ£o disponÃ­vel', 'info');
                    }
                    
                    // Configurar cÃ¢mera
                    await this.setupCamera();
                    
                    // Iniciar detecÃ§Ã£o
                    this.startDetection();
                    
                    console.log('âœ… Sistema de reconhecimento facial inicializado');
                } catch (error) {
                    console.error('âŒ Erro ao inicializar sistema:', error);
                    this.showError('Sistema de reconhecimento facial indisponÃ­vel');
                }
            }

            async checkCompreFaceStatus() {
                try {
                    // CompreFace nÃ£o tem endpoint /status, vamos testar com /faces
                    const response = await fetch(`${this.baseUrl}/api/v1/applications`, {
                        method: 'GET',
                        headers: {
                            'x-api-key': this.apiKey
                        },
                        timeout: 5000 // 5 segundos de timeout
                    });
                    
                    if (response.ok) {
                        console.log('âœ… CompreFace estÃ¡ online e configurado');
                        return true;
                    } else if (response.status === 400) {
                        // Status 400 pode significar que nÃ£o hÃ¡ faces cadastradas, mas a API estÃ¡ funcionando
                        console.log('âœ… CompreFace estÃ¡ online (sem faces cadastradas)');
                        return true;
                    } else {
                        throw new Error(`CompreFace nÃ£o disponÃ­vel: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('âš ï¸ CompreFace nÃ£o estÃ¡ disponÃ­vel:', error.message);
                    return false;
                }
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });

                    this.video = document.getElementById('faceVideo');
                    this.video.srcObject = stream;
                    
                    // Aguardar vÃ­deo carregar
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error(`Erro ao acessar cÃ¢mera: ${error.message}`);
                }
            }

            startDetection() {
                if (this.isDetecting) return;
                
                this.isDetecting = true;
                console.log('ðŸ” Iniciando detecÃ§Ã£o facial...');
                
                // Detectar faces a cada 2 segundos
                this.detectionInterval = setInterval(() => {
                    this.detectFaces();
                }, 2000);
            }

            async detectFaces() {
                try {
                    if (this.useSimulatedMode) {
                        // Modo simulado - simular detecÃ§Ã£o de rosto
                        this.simulateFaceDetection();
                        return;
                    }

                    // Capturar frame do vÃ­deo
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Converter para base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    const base64Data = imageData.split(',')[1];
                    
                    // Enviar para CompreFace - DetecÃ§Ã£o de faces
                    const response = await fetch(`${this.baseUrl}/faces/detect`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey
                        },
                        body: JSON.stringify({
                            file: base64Data
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Erro na detecÃ§Ã£o: ${response.status}`);
                    }

                    const result = await response.json();
                    this.processDetectionResult(result);
                    
                } catch (error) {
                    console.error('Erro na detecÃ§Ã£o facial:', error);
                    // Se falhar, tentar modo simulado
                    if (!this.useSimulatedMode) {
                        console.log('ðŸ”„ Tentando modo simulado...');
                        this.useSimulatedMode = true;
                        this.simulateFaceDetection();
                    }
                }
            }

            simulateFaceDetection() {
                // Simular detecÃ§Ã£o de rosto apÃ³s alguns segundos
                const randomDelay = Math.random() * 3000 + 2000; // 2-5 segundos
                
                setTimeout(async () => {
                    if (this.isDetecting) {
                        console.log('ðŸŽ­ Simulando detecÃ§Ã£o de rosto...');
                        
                        // Usar o usuÃ¡rio real "Lucas Brasil Lima" para simulaÃ§Ã£o
                        const usuarioSimulado = { nome_completo: 'Lucas Brasil Lima', matricula: '55942', empresa: 'Conexo', cargo: 'Assistente Administrativo' };
                        this.subjectId = usuarioSimulado.nome_completo;
                        
                        // Simular resultado de reconhecimento
                        this.processRecognitionResult({
                            result: [{
                                subjects: [{
                                    subject: usuarioSimulado.nome_completo,
                                    similarity: 0.85
                                }]
                            }]
                        });
                    }
                }, randomDelay);
            }

            processDetectionResult(result) {
                if (result.result && result.result.length > 0) {
                    console.log('ðŸ‘¤ Rosto detectado!');
                    this.faceDetected = true;
                    this.updateStatus('Rosto detectado! Reconhecendo...', 'success');
                    
                    // Parar detecÃ§Ã£o e iniciar reconhecimento
                    this.stopDetection();
                    this.recognizeFace(result.result[0]);
                } else {
                    this.updateStatus('Posicione seu rosto na Ã¡rea demarcada', 'info');
                }
            }

            async recognizeFace(faceData) {
                try {
                    console.log('ðŸ” Iniciando reconhecimento...');
                    this.updateStatus('Reconhecendo identidade...', 'processing');
                    
                    if (this.useSimulatedMode) {
                        // Modo simulado - simular reconhecimento
                        setTimeout(async () => {
                            const isRecognized = Math.random() > 0.3; // 70% de chance de reconhecer
                            if (isRecognized) {
                                // Simular usuÃ¡rio reconhecido
                                const usuarioSimulado = {
                                    id: 'simulated_user_001',
                                    nome_completo: 'UsuÃ¡rio Teste',
                                    matricula: '12345',
                                    empresa: 'RandonCorp',
                                    cargo: 'Desenvolvedor'
                                };
                                
                                // Registrar acesso no Supabase
                                await this.registrarAcessoUsuario(usuarioSimulado, 'facial', 'sucesso', 0.85);
                                
                                this.handleRecognitionResult(true, `Bem-vindo, ${usuarioSimulado.nome_completo}!`);
                            } else {
                                this.handleRecognitionResult(false, 'UsuÃ¡rio nÃ£o reconhecido (Simulado)');
                            }
                        }, 2000);
                    } else {
                        // Modo real com CompreFace - Reconhecimento facial
                        await this.performRealRecognition(faceData);
                    }
                    
                } catch (error) {
                    console.error('Erro no reconhecimento:', error);
                    this.handleRecognitionResult(false, 'Erro no reconhecimento');
                }
            }

            async performRealRecognition(faceData) {
                try {
                    // Capturar frame do vÃ­deo para reconhecimento
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Converter para base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    const base64Data = imageData.split(',')[1];
                    
                    // Enviar para CompreFace - Reconhecimento
                    const response = await fetch(`${this.baseUrl}/faces/recognize`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey
                        },
                        body: JSON.stringify({
                            file: base64Data
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Erro no reconhecimento: ${response.status}`);
                    }

                    const result = await response.json();
                    this.processRecognitionResult(result);
                    
                } catch (error) {
                    console.error('Erro no reconhecimento real:', error);
                    this.handleRecognitionResult(false, 'Erro no reconhecimento');
                }
            }

            processRecognitionResult(result) {
                console.log('ðŸŽ¯ Resultado do reconhecimento:', result);
                
                if (result.result && result.result.length > 0) {
                    const recognition = result.result[0];
                    
                    // CompreFace retorna subjects com similarity
                    if (recognition.subjects && recognition.subjects.length > 0) {
                        const subject = recognition.subjects[0];
                        const similarity = subject.similarity || 0;
                        const subjectName = subject.subject;
                        
                        console.log(`ðŸ‘¤ UsuÃ¡rio reconhecido: ${subjectName} (similaridade: ${similarity})`);
                        
                        if (similarity >= this.recognitionThreshold) {
                            // UsuÃ¡rio reconhecido com sucesso
                            this.subjectId = subjectName;
                            this.handleRecognitionResult(true, `UsuÃ¡rio reconhecido: ${subjectName}`);
                        } else {
                            // Similaridade muito baixa
                            this.handleRecognitionResult(false, 'Similaridade muito baixa no reconhecimento');
                        }
                    } else {
                        // Nenhum usuÃ¡rio reconhecido
                        this.handleRecognitionResult(false, 'UsuÃ¡rio nÃ£o encontrado no banco de dados');
                    }
                } else {
                    // Nenhum resultado
                    this.handleRecognitionResult(false, 'Nenhum rosto detectado');
                }
            }

            // Registrar acesso do usuÃ¡rio no Supabase
            async registrarAcessoUsuario(usuario, tipoAcesso, status, confianca) {
                try {
                    if (window.supabaseManager) {
                        await window.supabaseManager.registrarAcesso(
                            usuario.id,
                            tipoAcesso,
                            status,
                            confianca,
                            null,
                            null,
                            this.useSimulatedMode ? 'Modo simulado ativo' : 'Reconhecimento facial real'
                        );
                        
                        // Atualizar Ãºltimo acesso
                        await window.supabaseManager.atualizarUltimoAcesso(usuario.id);
                        
                        console.log('âœ… Acesso registrado no Supabase');
                    }
                } catch (error) {
                    console.error('Erro ao registrar acesso:', error);
                }
            }

            async handleRecognitionResult(success, message) {
                // Parar detecÃ§Ã£o imediatamente
                this.stopDetection();
                
                if (success) {
                    console.log('âœ… Reconhecimento bem-sucedido!');
                    this.updateStatus('Verificando usuÃ¡rio...', 'processing');
                    
                    // Buscar dados do usuÃ¡rio no Supabase pelo nome
                    if (this.subjectId && window.supabaseManager) {
                        try {
                            // Buscar usuÃ¡rio pelo nome (que Ã© o subject no CompreFace)
                            const usuario = await window.supabaseManager.buscarUsuarioPorNome(this.subjectId);
                            if (usuario) {
                                console.log('ðŸ‘¤ UsuÃ¡rio encontrado:', usuario);
                                
                                // Registrar acesso no Supabase
                                await this.registrarAcessoUsuario(usuario, 'facial', 'sucesso', 0.9);
                                
                                // Atualizar tÃ­tulo da tela com nome do usuÃ¡rio
                                this.updateTitle(`Bem-vindo, ${usuario.nome_completo}!`);
                                
                                // Redirecionar apÃ³s 3 segundos
                                setTimeout(() => {
                                    this.redirectToWelcome(usuario);
                                }, 3000);
                            } else {
                                console.log('âš ï¸ UsuÃ¡rio nÃ£o encontrado no banco de dados');
                                this.updateStatus('UsuÃ¡rio nÃ£o cadastrado no sistema', 'error');
                                
                                // Mostrar botÃ£o de reiniciar
                                this.showRestartButton();
                                console.log('ðŸ›‘ Sistema pausado - aguardando aÃ§Ã£o do usuÃ¡rio');
                            }
                        } catch (error) {
                            console.error('Erro ao buscar usuÃ¡rio:', error);
                            this.updateStatus('Erro ao verificar usuÃ¡rio', 'error');
                        }
                    } else {
                        // Redirecionar sem dados do usuÃ¡rio
                        setTimeout(() => {
                            this.redirectToWelcome();
                        }, 2000);
                    }
                } else {
                    console.log('âŒ Reconhecimento falhou');
                    this.updateStatus('Acesso negado. Tente novamente.', 'error');
                    
                    // Mostrar botÃ£o de reiniciar
                    this.showRestartButton();
                    console.log('ðŸ›‘ Sistema pausado - aguardando aÃ§Ã£o do usuÃ¡rio');
                }
            }

            updateStatus(message, type) {
                const statusElement = document.getElementById('detectionStatus');
                if (statusElement) {
                    const icon = statusElement.querySelector('.material-symbols-outlined');
                    const text = statusElement.querySelector('span:last-child');
                    
                    // Atualizar Ã­cone baseado no tipo
                    switch (type) {
                        case 'success':
                            icon.textContent = 'check_circle';
                            statusElement.style.color = '#00FF80';
                            break;
                        case 'error':
                            icon.textContent = 'error';
                            statusElement.style.color = '#FF4444';
                            break;
                        case 'processing':
                            icon.textContent = 'sync';
                            statusElement.style.color = '#FFA500';
                            break;
                        default:
                            icon.textContent = 'search';
                            statusElement.style.color = '#00FFC0';
                    }
                    
                    text.textContent = message;
                }
            }

            updateTitle(message) {
                const titleElement = document.querySelector('.scanner-title');
                if (titleElement) {
                    titleElement.textContent = message;
                    titleElement.style.color = '#00FF80';
                    titleElement.style.fontSize = '2.5rem';
                    titleElement.style.fontWeight = 'bold';
                    titleElement.style.textShadow = '0 0 20px rgba(0, 255, 128, 0.8)';
                }
            }

            showRestartButton() {
                const restartButton = document.getElementById('restartButton');
                if (restartButton) {
                    restartButton.style.opacity = '1';
                }
            }

            hideRestartButton() {
                const restartButton = document.getElementById('restartButton');
                if (restartButton) {
                    restartButton.style.opacity = '0';
                }
            }

            redirectToWelcome(usuario = null) {
                // Implementar redirecionamento ou prÃ³xima aÃ§Ã£o
                console.log('ðŸš€ Redirecionando para tela de boas-vindas...');
                
                if (usuario) {
                    console.log(`ðŸ‘‹ Bem-vindo, ${usuario.nome_completo}!`);
                    console.log(`ðŸ“‹ MatrÃ­cula: ${usuario.matricula}`);
                    console.log(`ðŸ¢ Empresa: ${usuario.empresa}`);
                    console.log(`ðŸ’¼ Cargo: ${usuario.cargo}`);
                    
                    // Salvar dados do usuÃ¡rio no localStorage
                    localStorage.setItem('usuarioAtual', JSON.stringify(usuario));
                    localStorage.setItem('ultimoAcesso', new Date().toISOString());
                }
                
                // Aqui vocÃª pode redirecionar para outra pÃ¡gina ou executar aÃ§Ã£o
                // Por exemplo: window.location.href = 'tela_boas_vindas.html';
            }

            showError(message) {
                this.updateStatus(message, 'error');
            }

            stopDetection() {
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                    this.detectionInterval = null;
                }
                this.isDetecting = false;
            }

            stop() {
                this.stopDetection();
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
            }
        }

        // Sistema de Reconhecimento de Voz - REMOVIDO
        /*
        class VoiceRecognitionSystem {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.attempts = 0;
                this.maxAttempts = 2;
                this.currentLanguage = 'pt-BR';
                this.languages = ['pt-BR', 'en-US', 'es-ES'];
                
                // Sistema de escalonamento de alertas
                this.alertHistory = [];
                this.alertThreshold = 3; // 3 confusÃµes em 5 minutos
                this.alertWindow = 5 * 60 * 1000; // 5 minutos em ms
                this.highPriorityThreshold = 5; // 5 confusÃµes = prioridade alta
                
                // Sistema de captura de Ã¡udio
                this.audioBuffer = [];
                this.audioBufferSize = 5; // 5 segundos
                this.audioSampleRate = 44100;
                this.audioChannels = 1;
                this.audioContext = null;
                this.audioWorklet = null;
                this.isRecording = false;
                this.confusionPatterns = {
                    'pt-BR': [
                        'o que Ã© isso', 'nÃ£o entendi', 'como funciona', 'o que fazer',
                        'nÃ£o sei', 'como usar', 'o que devo falar', 'nÃ£o compreendi',
                        'o que Ã©', 'como Ã© que funciona', 'nÃ£o entendi nada', 'nÃ£o saquei',
                        'nÃ£o compreendi nada', 'o que devo fazer', 'como Ã© que usa',
                        'nÃ£o entendi como', 'o que Ã© para fazer', 'como funciona isso',
                        'nÃ£o sei o que fazer', 'o que Ã© isso aqui', 'como Ã© que Ã©',
                        'nÃ£o entendi nada disso', 'o que Ã© para falar', 'como usar isso',
                        'nÃ£o sei como funciona', 'o que Ã© para dizer', 'como Ã© que funciona isso'
                    ],
                    'en-US': [
                        'what is this', 'i don\'t understand', 'how does it work', 'what to do',
                        'i don\'t know', 'how to use', 'what should i say', 'i don\'t get it',
                        'what is', 'how does this work', 'i don\'t understand anything',
                        'what is this for', 'how do i use this', 'what am i supposed to do',
                        'i don\'t get how', 'what is this thing', 'how does this thing work',
                        'i don\'t know what to do', 'what is this here', 'how is this',
                        'i don\'t understand any of this', 'what am i supposed to say',
                        'how do i use this thing', 'i don\'t know how this works',
                        'what am i supposed to tell', 'how does this thing work'
                    ],
                    'es-ES': [
                        'quÃ© es esto', 'no entiendo', 'cÃ³mo funciona', 'quÃ© hacer',
                        'no sÃ©', 'cÃ³mo usar', 'quÃ© debo decir', 'no comprendo',
                        'quÃ© es', 'cÃ³mo funciona esto', 'no entiendo nada', 'no capto',
                        'no comprendo nada', 'quÃ© debo hacer', 'cÃ³mo es que se usa',
                        'no entiendo cÃ³mo', 'quÃ© es para hacer', 'cÃ³mo funciona esto',
                        'no sÃ© quÃ© hacer', 'quÃ© es esto aquÃ­', 'cÃ³mo es que es',
                        'no entiendo nada de esto', 'quÃ© es para hablar', 'cÃ³mo usar esto',
                        'no sÃ© cÃ³mo funciona', 'quÃ© es para decir', 'cÃ³mo es que funciona esto'
                    ]
                };
                this.matriculaPatterns = {
                    'pt-BR': [
                        /(?:minha matrÃ­cula Ã©|matrÃ­cula|matricula|meu nÃºmero Ã©|nÃºmero)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'en-US': [
                        /(?:my id is|id number|student id|my number is|number)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ],
                    'es-ES': [
                        /(?:mi matrÃ­cula es|matrÃ­cula|mi nÃºmero es|nÃºmero)\s*(\d{4,8})/gi,
                        /(\d{4,8})/g
                    ]
                };
                this.init();
            }

            init() {
                this.setupSpeechRecognition();
                this.setupLanguageDetection();
            }

            setupSpeechRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.error('Speech Recognition nÃ£o suportado neste navegador');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = this.currentLanguage;
                this.recognition.maxAlternatives = 3;

                this.recognition.onstart = () => {
                    console.log('ðŸŽ¤ Iniciando reconhecimento de voz...');
                    this.isListening = true;
                    this.onVoiceStart();
                };

                this.recognition.onresult = (event) => {
                    this.processSpeechResult(event);
                };

                this.recognition.onerror = (event) => {
                    console.error('Erro no reconhecimento:', event.error);
                    this.handleRecognitionError(event.error);
                };

                this.recognition.onend = () => {
                    console.log('ðŸ”‡ Reconhecimento finalizado');
                    this.isListening = false;
                    this.onVoiceEnd();
                };
            }

            setupLanguageDetection() {
                // Detectar idioma baseado no texto falado
                this.detectLanguage = (text) => {
                    const lowerText = text.toLowerCase();
                    
                    // Verificar padrÃµes especÃ­ficos de cada idioma
                    if (this.confusionPatterns['pt-BR'].some(pattern => lowerText.includes(pattern))) {
                        return 'pt-BR';
                    } else if (this.confusionPatterns['en-US'].some(pattern => lowerText.includes(pattern))) {
                        return 'en-US';
                    } else if (this.confusionPatterns['es-ES'].some(pattern => lowerText.includes(pattern))) {
                        return 'es-ES';
                    }
                    
                    // Fallback para portuguÃªs
                    return 'pt-BR';
                };
            }

            processSpeechResult(event) {
                // Verificar se jÃ¡ atingiu o mÃ¡ximo de tentativas
                if (this.attempts >= this.maxAttempts) {
                    console.log('ðŸš« MÃ¡ximo de tentativas atingido, ignorando processamento');
                    return;
                }

                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Processar transcriÃ§Ã£o final
                if (finalTranscript) {
                    console.log('ðŸŽ¯ TranscriÃ§Ã£o final:', finalTranscript);
                    this.analyzeSpeech(finalTranscript);
                }

                // Mostrar transcriÃ§Ã£o interina
                if (interimTranscript) {
                    console.log('â³ Processando:', interimTranscript);
                    this.onInterimResult(interimTranscript);
                }
            }

            analyzeSpeech(text) {
                const lowerText = text.toLowerCase().trim();
                const detectedLanguage = this.detectLanguage(lowerText);
                
                console.log(`ðŸŒ Idioma detectado: ${detectedLanguage}`);
                console.log(`ðŸ“ Texto analisado: "${lowerText}"`);

                // NLU bÃ¡sico - classificar intenÃ§Ã£o
                const intent = this.classifyIntent(lowerText, detectedLanguage);
                console.log(`ðŸ§  IntenÃ§Ã£o detectada: ${intent.type} (confianÃ§a: ${intent.confidence})`);

                // 1. Verificar se Ã© confusÃ£o/dÃºvida
                if (intent.type === 'confusao' && intent.confidence > 0.7) {
                    console.log('â“ ConfusÃ£o detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 2. Verificar se Ã© dÃºvida
                if (intent.type === 'duvida' && intent.confidence > 0.7) {
                    console.log('â“ DÃºvida detectada via NLU!');
                    this.handleConfusion(text, detectedLanguage);
                    return;
                }

                // 3. Tentar extrair matrÃ­cula
                const matricula = this.extractMatricula(lowerText, detectedLanguage);
                if (matricula) {
                    console.log(`âœ… MatrÃ­cula extraÃ­da: ${matricula}`);
                    this.handleMatricula(matricula);
                    return;
                }

                // 4. Se nÃ£o conseguiu extrair nada, incrementar tentativas
                this.attempts++;
                console.log(`âš ï¸ Tentativa ${this.attempts}/${this.maxAttempts} - NÃ£o foi possÃ­vel extrair matrÃ­cula`);
                
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // NLU bÃ¡sico - classificar intenÃ§Ã£o
            classifyIntent(text, language) {
                const intents = {
                    'pt-BR': {
                        matricula: [
                            'matrÃ­cula', 'matricula', 'nÃºmero', 'numero', 'cÃ³digo', 'codigo',
                            'minha matrÃ­cula Ã©', 'meu nÃºmero Ã©', 'o nÃºmero Ã©', 'o cÃ³digo Ã©'
                        ],
                        confusao: [
                            'nÃ£o entendi', 'nÃ£o compreendi', 'nÃ£o saquei', 'nÃ£o captei',
                            'o que Ã© isso', 'o que Ã©', 'como funciona', 'o que fazer',
                            'nÃ£o sei', 'como usar', 'o que devo falar', 'nÃ£o compreendi nada',
                            'nÃ£o entendi nada', 'o que Ã© para fazer', 'como funciona isso',
                            'nÃ£o sei o que fazer', 'o que Ã© isso aqui', 'como Ã© que Ã©',
                            'nÃ£o entendi nada disso', 'o que Ã© para falar', 'como usar isso',
                            'nÃ£o sei como funciona', 'o que Ã© para dizer', 'como Ã© que funciona isso',
                            'ah, eu nÃ£o entendi', 'eu nÃ£o entendi o que tenho que falar',
                            'nÃ£o entendi o que tenho que fazer', 'o que eu tenho que falar'
                        ],
                        duvida: [
                            'posso entrar sem crachÃ¡', 'preciso falar algo', 'o que preciso fazer',
                            'como faÃ§o para entrar', 'posso passar', 'o que devo fazer',
                            'como funciona aqui', 'o que Ã© necessÃ¡rio', 'preciso de ajuda',
                            'nÃ£o sei o que fazer', 'o que eu faÃ§o', 'como proceder'
                        ]
                    },
                    'en-US': {
                        matricula: [
                            'id', 'number', 'code', 'my id is', 'my number is', 'the number is',
                            'student id', 'id number', 'my code is'
                        ],
                        confusao: [
                            'i don\'t understand', 'i don\'t get it', 'what is this', 'what is',
                            'how does it work', 'what to do', 'i don\'t know', 'how to use',
                            'what should i say', 'i don\'t understand anything', 'what is this for',
                            'how do i use this', 'what am i supposed to do', 'i don\'t get how',
                            'what is this thing', 'how does this thing work', 'i don\'t know what to do',
                            'what is this here', 'how is this', 'i don\'t understand any of this',
                            'what am i supposed to say', 'how do i use this thing', 'i don\'t know how this works',
                            'what am i supposed to tell', 'how does this thing work', 'ah, i don\'t understand',
                            'i don\'t understand what i have to say', 'i don\'t understand what i have to do'
                        ],
                        duvida: [
                            'can i enter without badge', 'do i need to say something', 'what do i need to do',
                            'how do i enter', 'can i pass', 'what should i do', 'how does this work here',
                            'what is needed', 'i need help', 'i don\'t know what to do', 'what do i do',
                            'how to proceed'
                        ]
                    },
                    'es-ES': {
                        matricula: [
                            'matrÃ­cula', 'nÃºmero', 'cÃ³digo', 'mi matrÃ­cula es', 'mi nÃºmero es',
                            'el nÃºmero es', 'el cÃ³digo es', 'cÃ³digo de estudiante'
                        ],
                        confusao: [
                            'no entiendo', 'no comprendo', 'no capto', 'quÃ© es esto', 'quÃ© es',
                            'cÃ³mo funciona', 'quÃ© hacer', 'no sÃ©', 'cÃ³mo usar', 'quÃ© debo decir',
                            'no comprendo nada', 'no entiendo nada', 'quÃ© es para hacer', 'cÃ³mo funciona esto',
                            'no sÃ© quÃ© hacer', 'quÃ© es esto aquÃ­', 'cÃ³mo es que es', 'no entiendo nada de esto',
                            'quÃ© es para hablar', 'cÃ³mo usar esto', 'no sÃ© cÃ³mo funciona', 'quÃ© es para decir',
                            'cÃ³mo es que funciona esto', 'ah, no entiendo', 'no entiendo quÃ© tengo que decir',
                            'no entiendo quÃ© tengo que hacer'
                        ],
                        duvida: [
                            'puedo entrar sin credencial', 'necesito decir algo', 'quÃ© necesito hacer',
                            'cÃ³mo hago para entrar', 'puedo pasar', 'quÃ© debo hacer', 'cÃ³mo funciona aquÃ­',
                            'quÃ© es necesario', 'necesito ayuda', 'no sÃ© quÃ© hacer', 'quÃ© hago',
                            'cÃ³mo proceder'
                        ]
                    }
                };

                const languageIntents = intents[language] || intents['pt-BR'];
                let bestIntent = { type: 'outros', confidence: 0 };

                // Verificar cada intenÃ§Ã£o
                for (const [intentType, patterns] of Object.entries(languageIntents)) {
                    let matches = 0;
                    let totalWords = text.split(' ').length;

                    for (const pattern of patterns) {
                        if (text.includes(pattern)) {
                            matches++;
                        }
                    }

                    const confidence = matches / Math.max(1, totalWords);
                    
                    if (confidence > bestIntent.confidence) {
                        bestIntent = { type: intentType, confidence: confidence };
                    }
                }

                return bestIntent;
            }

            isConfusion(text, language) {
                const patterns = this.confusionPatterns[language] || this.confusionPatterns['pt-BR'];
                return patterns.some(pattern => text.includes(pattern));
            }

            extractMatricula(text, language) {
                const patterns = this.matriculaPatterns[language] || this.matriculaPatterns['pt-BR'];
                
                for (const pattern of patterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[1] || match[0];
                    }
                }
                
                return null;
            }

            async handleConfusion(text, language) {
                console.log('ðŸš¨ Enviando alerta de confusÃ£o para Teams...');
                
                const now = new Date();
                const alertData = {
                    type: 'confusion',
                    text: text,
                    language: language,
                    timestamp: now.toISOString(),
                    priority: 'normal'
                };
                
                // Adicionar ao histÃ³rico de alertas
                this.alertHistory.push(alertData);
                
                // Limpar alertas antigos (mais de 5 minutos)
                this.alertHistory = this.alertHistory.filter(
                    alert => now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                // Verificar escalonamento
                const recentConfusions = this.alertHistory.filter(
                    alert => alert.type === 'confusion' && 
                    now.getTime() - new Date(alert.timestamp).getTime() < this.alertWindow
                );
                
                if (recentConfusions.length >= this.alertThreshold) {
                    alertData.priority = recentConfusions.length >= this.highPriorityThreshold ? 'high' : 'medium';
                    console.log(`ðŸš¨ ESCALONAMENTO: ${recentConfusions.length} confusÃµes em 5 minutos - Prioridade: ${alertData.priority}`);
                }
                
                // Salvar Ã¡udio de 5s no Supabase Storage
                const audioFileName = await this.saveAudioToSupabase('confusion', text, language);
                if (audioFileName) {
                    alertData.audioFile = audioFileName;
                }
                
                // Log de auditoria no Supabase
                this.logAuditEvent(alertData);
                
                // Enviar webhook com prioridade
                this.sendTeamsWebhook(alertData);
            }

            handleMatricula(matricula) {
                console.log(`ðŸ” Buscando usuÃ¡rio com matrÃ­cula: ${matricula}`);
                this.searchUser(matricula);
            }

            handleMaxAttemptsReached() {
                console.log('ðŸš¨ MÃ¡ximo de tentativas atingido!');
                this.sendTeamsWebhook({
                    type: 'max_attempts',
                    priority: 'high',
                    attempts: this.attempts,
                    timestamp: new Date().toISOString()
                });
                this.attempts = 0;
                // Parar o reconhecimento de voz
                this.stopListening();
            }

            async searchUser(matricula) {
                try {
                    const { data, error } = await supabase
                        .from('usuarios')
                        .select('*')
                        .eq('matricula', matricula)
                        .maybeSingle();

                    if (error) {
                        console.error('Erro ao buscar usuÃ¡rio:', error);
                        return;
                    }

                    if (data) {
                        console.log('âœ… UsuÃ¡rio encontrado:', data);
                        this.onUserFound(data);
                    } else {
                        console.log('âŒ UsuÃ¡rio nÃ£o encontrado');
                        this.onUserNotFound(matricula);
                    }
                } catch (error) {
                    console.error('Erro na busca:', error);
                }
            }

            sendTeamsWebhook(data) {
                // Webhook do Teams com CORS - usar proxy ou fallback
                console.log('ðŸ“¡ Tentando enviar webhook para Teams...');
                
                // Como hÃ¡ problema de CORS, vamos usar fallback direto
                this.sendEmailFallback(data);
                return;
                
                // Cores baseadas na prioridade
                const priorityColors = {
                    'normal': '0076D7',
                    'medium': 'FF8C00',
                    'high': 'DC143C'
                };
                
                const priorityEmojis = {
                    'normal': 'ðŸš¨',
                    'medium': 'âš ï¸',
                    'high': 'ðŸ”¥'
                };
                
                // Garantir que data.priority existe
                const priority = data.priority || 'normal';
                const color = priorityColors[priority] || priorityColors['normal'];
                const emoji = priorityEmojis[priority] || priorityEmojis['normal'];
                
                const message = {
                    "@type": "MessageCard",
                    "@context": "http://schema.org/extensions",
                    "themeColor": color,
                    "summary": `Alerta do Sistema de Voz - ${priority.toUpperCase()}`,
                    "sections": [{
                        "activityTitle": `${emoji} Alerta do Sistema de Reconhecimento de Voz`,
                        "activitySubtitle": `Tipo: ${data.type || 'confusao'} | Prioridade: ${priority.toUpperCase()}`,
                        "facts": [
                            { "name": "Timestamp", "value": data.timestamp },
                            { "name": "Tentativas", "value": data.attempts || 'N/A' },
                            { "name": "Texto", "value": data.text || 'N/A' },
                            { "name": "Idioma", "value": data.language || 'N/A' },
                            { "name": "Prioridade", "value": data.priority.toUpperCase() }
                        ]
                    }]
                };

                fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(message)
                }).then(response => {
                    if (response.ok) {
                        console.log('âœ… Webhook Teams enviado com sucesso');
                        // Log status de sucesso
                        this.logAuditEvent({
                            ...data,
                            type: 'webhook_status',
                            status: 'teams_ok',
                            message: 'Webhook Teams enviado com sucesso'
                        });
                    } else {
                        console.error('Erro ao enviar webhook Teams:', response.status);
                        // Fallback para email se Teams falhar
                        this.sendEmailFallback(data);
                    }
                }).catch(error => {
                    console.error('Erro ao enviar webhook:', error);
                    // Fallback para email se Teams falhar
                    this.sendEmailFallback(data);
                });
            }

            // Fallback para email se Teams falhar
            sendEmailFallback(data) {
                console.log('ðŸ“§ Enviando fallback por email...');
                // Aqui vocÃª pode implementar envio de email via API
                // Por exemplo, usando SendGrid, AWS SES, etc.
                this.logAuditEvent({
                    ...data,
                    type: 'email_fallback',
                    message: 'Teams webhook falhou, enviado por email'
                });
            }

            // Sistema de captura de Ã¡udio
            async setupAudioRecording() {
                try {
                    // Usar o mesmo AudioContext do setupAudioAnalysis
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: this.audioSampleRate
                        });
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: this.audioSampleRate,
                            channelCount: this.audioChannels,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    
                    // Usar AudioWorkletNode em vez de ScriptProcessorNode (deprecated)
                    if (this.audioContext.audioWorklet) {
                        try {
                            await this.audioContext.audioWorklet.addModule('data:application/javascript;base64,' + btoa(`
                                class AudioRecorderProcessor extends AudioWorkletProcessor {
                                    constructor() {
                                        super();
                                        this.bufferSize = 4096;
                                        this.buffer = [];
                                    }
                                    
                                    process(inputs, outputs, parameters) {
                                        const input = inputs[0];
                                        if (input.length > 0) {
                                            this.buffer.push(new Float32Array(input[0]));
                                            
                                            if (this.buffer.length > 100) { // ~5 segundos
                                                this.buffer.shift();
                                            }
                                            
                                            this.port.postMessage({
                                                type: 'audioData',
                                                data: new Float32Array(input[0])
                                            });
                                        }
                                        return true;
                                    }
                                }
                                registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
                            `));
                            
                            this.audioWorklet = new AudioWorkletNode(this.audioContext, 'audio-recorder-processor');
                            this.audioWorklet.port.onmessage = (event) => {
                                if (event.data.type === 'audioData' && this.isRecording) {
                                    this.audioBuffer.push(event.data.data);
                                    
                                    // Manter apenas os Ãºltimos 5 segundos
                                    const maxSamples = this.audioSampleRate * this.audioBufferSize;
                                    if (this.audioBuffer.length * 4096 > maxSamples) {
                                        this.audioBuffer.shift();
                                    }
                                }
                            };
                            
                            source.connect(this.audioWorklet);
                            console.log('ðŸŽ™ï¸ Sistema de gravaÃ§Ã£o de Ã¡udio configurado (AudioWorklet)');
                        } catch (workletError) {
                            console.warn('AudioWorklet nÃ£o suportado, usando ScriptProcessor:', workletError);
                            this.setupScriptProcessor(source);
                        }
                    } else {
                        this.setupScriptProcessor(source);
                    }
                } catch (error) {
                    console.error('Erro ao configurar gravaÃ§Ã£o de Ã¡udio:', error);
                }
            }

            setupScriptProcessor(source) {
                const processor = this.audioContext.createScriptProcessor(4096, this.audioChannels, this.audioChannels);
                
                processor.onaudioprocess = (event) => {
                    if (this.isRecording) {
                        const inputData = event.inputBuffer.getChannelData(0);
                        this.audioBuffer.push(new Float32Array(inputData));
                        
                        // Manter apenas os Ãºltimos 5 segundos
                        const maxSamples = this.audioSampleRate * this.audioBufferSize;
                        if (this.audioBuffer.length * 4096 > maxSamples) {
                            this.audioBuffer.shift();
                        }
                    }
                };
                
                source.connect(processor);
                processor.connect(this.audioContext.destination);
                console.log('ðŸŽ™ï¸ Sistema de gravaÃ§Ã£o de Ã¡udio configurado (ScriptProcessor)');
            }

            startAudioRecording() {
                this.isRecording = true;
                this.audioBuffer = [];
                console.log('ðŸ”´ Iniciando gravaÃ§Ã£o de Ã¡udio...');
            }

            stopAudioRecording() {
                this.isRecording = false;
                console.log('â¹ï¸ Parando gravaÃ§Ã£o de Ã¡udio...');
            }

            async saveAudioToSupabase(eventType, text, language) {
                if (this.audioBuffer.length === 0) {
                    console.log('âš ï¸ Nenhum Ã¡udio para salvar');
                    return null;
                }

                try {
                    // Converter buffer para WAV
                    const wavBlob = this.audioToWav(this.audioBuffer);
                    
                    // Gerar nome Ãºnico para o arquivo
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const fileName = `audio_${eventType}_${timestamp}.wav`;
                    
                    // Upload para Supabase Storage
                    const { data, error } = await supabase.storage
                        .from('voice-audio')
                        .upload(fileName, wavBlob, {
                            contentType: 'audio/wav',
                            cacheControl: '3600'
                        });

                    if (error) {
                        console.error('Erro ao fazer upload do Ã¡udio:', error);
                        return null;
                    }

                    console.log('âœ… Ãudio salvo no Supabase Storage:', fileName);
                    return fileName;
                } catch (error) {
                    console.error('Erro ao salvar Ã¡udio:', error);
                    return null;
                }
            }

            audioToWav(audioBuffer) {
                const length = audioBuffer.reduce((acc, buffer) => acc + buffer.length, 0);
                const arrayBuffer = new ArrayBuffer(44 + length * 2);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, this.audioChannels, true);
                view.setUint32(24, this.audioSampleRate, true);
                view.setUint32(28, this.audioSampleRate * this.audioChannels * 2, true);
                view.setUint16(32, this.audioChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * 2, true);
                
                // Audio data
                let offset = 44;
                for (const buffer of audioBuffer) {
                    for (let i = 0; i < buffer.length; i++) {
                        const sample = Math.max(-1, Math.min(1, buffer[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            startListening() {
                if (this.recognition && !this.isListening) {
                    this.attempts = 0;
                    this.recognition.start();
                    this.startAudioRecording();
                }
            }

            stopListening() {
                if (this.recognition && this.isListening) {
                    this.recognition.stop();
                    this.stopAudioRecording();
                }
            }

            // Callbacks para integraÃ§Ã£o com ondas sonoras
            onVoiceStart() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.startListening();
                }
            }

            onVoiceEnd() {
                if (window.sonicWaveform) {
                    window.sonicWaveform.stopListening();
                }
            }

            onInterimResult(text) {
                if (window.sonicWaveform) {
                    // Simular intensidade baseada no comprimento do texto
                    const intensity = Math.min(1, text.length / 50);
                    window.sonicWaveform.updateVoiceData(intensity, 1, 1);
                }
            }

            // Web Audio API para anÃ¡lise de Ã¡udio em tempo real
            setupAudioAnalysis() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.audioSampleRate
                    });
                }
                
                if (!this.analyser) {
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.analyser.smoothingTimeConstant = 0.8;
                }
                
                if (!this.microphone) {
                    navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: this.audioSampleRate,
                            channelCount: this.audioChannels,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    })
                        .then(stream => {
                            this.microphone = this.audioContext.createMediaStreamSource(stream);
                            this.microphone.connect(this.analyser);
                            this.startAudioAnalysis();
                        })
                        .catch(error => console.error('Erro ao acessar microfone:', error));
                }
            }

            startAudioAnalysis() {
                if (!this.analyser) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const timeDomainData = new Float32Array(this.analyser.fftSize);
                
                // VAD (Voice Activity Detection) - detectar se Ã© voz humana
                let voiceThreshold = 0.01; // Threshold para detectar voz
                let silenceCounter = 0;
                let maxSilenceFrames = 30; // 30 frames de silÃªncio = parar
                
                const analyze = () => {
                    if (this.isListening) {
                        this.analyser.getByteFrequencyData(dataArray);
                        this.analyser.getFloatTimeDomainData(timeDomainData);
                        
                        // Calcular RMS (Root Mean Square) para intensidade
                        const rms = Math.sqrt(dataArray.reduce((sum, value) => sum + value * value, 0) / dataArray.length) / 255;
                        
                        // VAD - detectar se Ã© voz humana
                        const isVoice = this.detectVoice(dataArray, timeDomainData);
                        
                        if (isVoice) {
                            silenceCounter = 0;
                            
                            // FFT - AnÃ¡lise de frequÃªncia real
                            const frequencyData = this.analyzeFrequencySpectrum(dataArray);
                            
                            // Atualizar ondas sonoras com dados reais de voz
                            if (window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(
                                    frequencyData.intensity,
                                    frequencyData.dominantFreq,
                                    frequencyData.amplitude
                                );
                            }
                        } else {
                            silenceCounter++;
                            
                            // Se muito silÃªncio, reduzir intensidade das ondas
                            if (silenceCounter > maxSilenceFrames && window.sonicWaveform) {
                                window.sonicWaveform.updateVoiceData(0.1, 0.5, 0.1);
                            }
                        }
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }

            // Detectar se Ã© voz humana (VAD)
            detectVoice(frequencyData, timeDomainData) {
                // Calcular energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                
                // Calcular energia em frequÃªncias de voz (300Hz - 3400Hz)
                const voiceStart = Math.floor(300 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnd = Math.floor(3400 * frequencyData.length / (this.analyser.sampleRate / 2));
                const voiceEnergy = frequencyData.slice(voiceStart, voiceEnd).reduce((sum, value) => sum + value, 0) / (voiceEnd - voiceStart);
                
                // Calcular energia em frequÃªncias de ruÃ­do (0-300Hz, 3400Hz+)
                const noiseEnergy = (frequencyData.slice(0, voiceStart).reduce((sum, value) => sum + value, 0) + 
                                   frequencyData.slice(voiceEnd).reduce((sum, value) => sum + value, 0)) / 
                                   (voiceStart + frequencyData.length - voiceEnd);
                
                // Detectar voz se energia de voz > ruÃ­do e total > threshold
                const voiceRatio = voiceEnergy / (noiseEnergy + 0.001);
                const isVoice = totalEnergy > this.voiceThreshold && voiceRatio > 1.5;
                
                return isVoice;
            }

            // AnÃ¡lise de espectro de frequÃªncia (FFT)
            analyzeFrequencySpectrum(frequencyData) {
                // Encontrar frequÃªncia dominante
                let maxValue = 0;
                let maxIndex = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                // Converter Ã­ndice para frequÃªncia real
                const dominantFreq = (maxIndex * this.analyser.sampleRate) / (2 * frequencyData.length);
                
                // Calcular intensidade normalizada
                const intensity = maxValue / 255;
                
                // Calcular amplitude baseada na energia total
                const totalEnergy = frequencyData.reduce((sum, value) => sum + value, 0) / frequencyData.length;
                const amplitude = Math.min(2, totalEnergy / 100);
                
                // Analisar formantes (caracterÃ­sticas da voz)
                const formants = this.analyzeFormants(frequencyData);
                
                return {
                    intensity: intensity,
                    dominantFreq: Math.min(3, dominantFreq / 1000), // Normalizar para 0-3
                    amplitude: amplitude,
                    formants: formants
                };
            }

            // AnÃ¡lise de formantes (caracterÃ­sticas Ãºnicas da voz)
            analyzeFormants(frequencyData) {
                const formants = [];
                const sampleRate = this.analyser.sampleRate;
                const nyquist = sampleRate / 2;
                
                // Procurar picos de energia (formantes)
                for (let i = 1; i < frequencyData.length - 1; i++) {
                    if (frequencyData[i] > frequencyData[i-1] && 
                        frequencyData[i] > frequencyData[i+1] && 
                        frequencyData[i] > 50) { // Threshold mÃ­nimo
                        
                        const freq = (i * nyquist) / frequencyData.length;
                        if (freq > 200 && freq < 4000) { // Range de formantes
                            formants.push({
                                frequency: freq,
                                amplitude: frequencyData[i] / 255
                            });
                        }
                    }
                }
                
                return formants;
            }

            onUserFound(user) {
                console.log('ðŸŽ‰ UsuÃ¡rio validado com sucesso!');
                // Redirecionar para tela de sucesso
                setTimeout(() => {
                    window.location.href = 'tela_depois_cracha.html';
                }, 1000);
            }

            onUserNotFound(matricula) {
                console.log('âŒ MatrÃ­cula nÃ£o encontrada no sistema');
                this.attempts++;
                if (this.attempts >= this.maxAttempts) {
                    this.handleMaxAttemptsReached();
                }
            }

            // Log de auditoria no Supabase
            async logAuditEvent(eventData) {
                try {
                    const { error } = await supabase
                        .from('audit_logs')
                        .insert([{
                            event_type: eventData.type,
                            text: eventData.text,
                            language: eventData.language,
                            attempts: eventData.attempts || 0,
                            timestamp: eventData.timestamp,
                            created_at: new Date().toISOString()
                        }]);

                    if (error) {
                        console.error('Erro ao salvar log de auditoria:', error);
                    } else {
                        console.log('âœ… Log de auditoria salvo com sucesso');
                    }
                } catch (error) {
                    console.error('Erro na funÃ§Ã£o de log:', error);
                }
            }
        }
        */

        // Sonic Waveform Canvas Class
        class SonicWaveformCanvas {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { willReadFrequently: true });
                this.animationFrameId = null;
                this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };
                this.time = 0;
                
                // Voice detection properties
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.draw();
                this.setupEventListeners();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            draw() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const lineCount = 60;
                const segmentCount = 80;
                const height = this.canvas.height / 2;
                
                // Voice detection effects
                const voiceEffect = this.isListening ? this.voiceIntensity : 0;
                const voiceAmplitude = this.isListening ? this.voiceAmplitude : 1;
                const voiceFreq = this.isListening ? this.voiceFrequency : 1;
                
                for (let i = 0; i < lineCount; i++) {
                    this.ctx.beginPath();
                    const progress = i / lineCount;
                    const colorIntensity = Math.sin(progress * Math.PI);
                    
                    // Voice affects color intensity
                    const voiceColorIntensity = colorIntensity * (1 + voiceEffect * 0.5);
                    this.ctx.strokeStyle = `rgba(0, 255, 192, ${voiceColorIntensity * 0.5})`;
                    this.ctx.lineWidth = 1.5 + (voiceEffect * 2);

                    for (let j = 0; j < segmentCount + 1; j++) {
                        const x = (j / segmentCount) * this.canvas.width;
                        
                        // Mouse influence (desabilitado para touch screen)
                        const distToMouse = Math.hypot(x - this.mouse.x, (height) - this.mouse.y);
                        const mouseEffect = Math.max(0, 1 - distToMouse / 400);

                        // Wave calculation with voice effects
                        const noise = Math.sin(j * 0.1 + this.time + i * 0.2) * 20;
                        const spike = Math.cos(j * 0.2 + this.time + i * 0.1) * Math.sin(j * 0.05 + this.time) * 50;
                        
                        // Voice detection adds dynamic effects
                        const voiceNoise = this.isListening ? 
                            Math.sin(j * voiceFreq * 0.1 + this.time + i * 0.2) * 30 * voiceEffect : 0;
                        const voiceSpike = this.isListening ? 
                            Math.cos(j * voiceFreq * 0.2 + this.time + i * 0.1) * Math.sin(j * voiceFreq * 0.05 + this.time) * 80 * voiceEffect : 0;
                        
                        const y = height + noise + spike * (1 + mouseEffect * 2) + 
                                 voiceNoise + voiceSpike * voiceAmplitude;
                        
                        if (j === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                }

                this.time += 0.02;
                this.animationFrameId = requestAnimationFrame(() => this.draw());
            }

            setupEventListeners() {
                const handleResize = () => {
                    this.resizeCanvas();
                };

                window.addEventListener('resize', handleResize);
                
                // Cleanup function
                this.cleanup = () => {
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                    }
                    window.removeEventListener('resize', handleResize);
                };
            }

            resize() {
                this.resizeCanvas();
            }

            destroy() {
                if (this.cleanup) {
                    this.cleanup();
                }
            }

            // Voice detection methods
            startListening() {
                this.isListening = true;
                this.voiceIntensity = 0.5;
                this.voiceFrequency = 1;
                this.voiceAmplitude = 1;
            }

            stopListening() {
                this.isListening = false;
                this.voiceIntensity = 0;
                this.voiceFrequency = 0;
                this.voiceAmplitude = 0;
            }

            updateVoiceData(intensity, frequency, amplitude) {
                this.voiceIntensity = Math.min(1, Math.max(0, intensity));
                this.voiceFrequency = Math.min(3, Math.max(0.5, frequency));
                this.voiceAmplitude = Math.min(2, Math.max(0.5, amplitude));
            }

            // Simulate voice detection for testing
            simulateVoiceDetection() {
                if (this.isListening) {
                    // Simulate random voice data
                    const intensity = 0.3 + Math.random() * 0.7;
                    const frequency = 0.8 + Math.random() * 1.4;
                    const amplitude = 0.8 + Math.random() * 1.2;
                    
                    this.updateVoiceData(intensity, frequency, amplitude);
                }
            }
        }

        // Sistema de Scanner de CÃ³digo de Barras - REMOVIDO
        /*
        class BarcodeScanner {
            constructor() {
                this.isScanning = false;
                this.currentStream = null;
                this.supabaseUrl = 'https://cretuodvidcfqwgpnauz.supabase.co';
                this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNyZXR1b2R2aWRjZnF3Z3BuYXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MTA5MDIsImV4cCI6MjA3Mzk4NjkwMn0.6WxPs27ox3DAOC2HiW0QTQl4AXxNNlNsWjKlB0NdVQY';
                this.supabase = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'environment'
                        } 
                    });
                    
                    this.currentStream = stream;
                    const video = document.getElementById('scannerVideo');
                    video.srcObject = stream;
                    
                    video.onloadedmetadata = () => {
                        video.play();
                        // Aguardar o vÃ­deo estar reproduzindo antes de iniciar o scanner
                        video.onplaying = () => {
                            console.log('VÃ­deo estÃ¡ reproduzindo, iniciando scanner...');
                            setTimeout(() => {
                                this.startScanner();
                            }, 1000); // Aguardar 1 segundo para garantir estabilidade
                        };
                    };
                    
                } catch (error) {
                    console.error('Erro ao acessar webcam:', error);
                    this.showError('Webcam nÃ£o disponÃ­vel');
                }
            }

            startScanner() {
                if (this.isScanning) return;
                
                console.log('Iniciando scanner de cÃ³digo de barras...');
                this.isScanning = true;
                const videoElement = document.getElementById('scannerVideo');
                
                if (!videoElement) {
                    console.error('Elemento de vÃ­deo nÃ£o encontrado');
                    this.showError('Elemento de vÃ­deo nÃ£o encontrado');
                    return;
                }
                
                console.log('Elemento de vÃ­deo encontrado:', videoElement);
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: videoElement,
                        constraints: {
                            width: 640,
                            height: 480,
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader",
                            "ean_reader",
                            "code_39_reader",
                            "ean_8_reader",
                            "upc_reader"
                        ],
                        debug: {
                            drawBoundingBox: true,
                            showFrequency: false,
                            showDetectedRegion: false,
                            showSkeleton: false,
                            showLabels: false,
                            showPatch: false,
                            showBoxes: false
                        }
                    },
                    locate: true,
                    locator: {
                        patchSize: "large",
                        halfSample: false
                    },
                    numOfWorkers: 2,
                    frequency: 10,
                    debug: false
                }, (err) => {
                    if (err) {
                        console.error('Erro ao inicializar scanner:', err);
                        this.showError('Erro ao inicializar scanner');
                        return;
                    }
                    
                    console.log('Scanner inicializado com sucesso');
                    Quagga.start();
                    this.showQualityIndicator();
                    
                    // Adicionar listener para debug de processamento
                    let frameCount = 0;
                    Quagga.onProcessed((result) => {
                        frameCount++;
                        if (frameCount % 30 === 0) {
                            console.log('ðŸ”„ Processando frame...', frameCount);
                        }
                        if (result && result.codeResult) {
                            console.log('ðŸŽ¯ CÃ³digo encontrado no processamento:', result.codeResult);
                        }
                    });
                });
                
                Quagga.onDetected((result) => {
                    console.log('ðŸŽ¯ CÃ³digo detectado pelo Quagga:', result);
                    if (result && result.codeResult) {
                        const code = result.codeResult.code;
                        const confidence = result.codeResult.confidence;
                        console.log('âœ… CÃ³digo vÃ¡lido detectado:', code, 'ConfianÃ§a:', confidence);
                        
                        Quagga.stop();
                        this.isScanning = false;
                        this.searchUser(code);
                    } else {
                        console.log('âŒ Resultado invÃ¡lido:', result);
                    }
                });
            }

            async searchUser(codigoBarras) {
                try {
                    this.showFeedback('Verificando acesso...', 'info');
                    
                    const { data, error } = await this.supabase
                        .from('usuarios')
                        .select('nome_completo, empresa')
                        .eq('codigo_barras', codigoBarras)
                        .maybeSingle();
                    
                    if (error) {
                        console.error('Erro na consulta:', error);
                        this.showFeedback('Erro na consulta do banco de dados', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    } else if (data) {
                        console.log('UsuÃ¡rio encontrado:', data);
                        this.showFeedback(`Acesso autorizado - ${data.nome_completo}!`, 'success');
                        setTimeout(() => {
                            this.redirectToWelcome(data.nome_completo);
                        }, 1500);
                    } else {
                        console.log('UsuÃ¡rio nÃ£o encontrado');
                        this.showFeedback('Acesso negado - UsuÃ¡rio nÃ£o cadastrado', 'error');
                        setTimeout(() => this.restartScanner(), 3000);
                    }
                    
                } catch (error) {
                    console.error('Erro na busca:', error);
                    this.showFeedback('Erro interno do sistema', 'error');
                    setTimeout(() => this.restartScanner(), 3000);
                }
            }

            showFeedback(message, type) {
                const feedback = document.createElement('div');
                feedback.className = `fixed top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg text-white font-semibold z-50 ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    'bg-blue-500'
                }`;
                feedback.textContent = message;
                
                document.body.appendChild(feedback);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.remove();
                    }
                }, 3000);
            }

            redirectToWelcome(nomeCompleto) {
                const primeiroNome = nomeCompleto.split(' ')[0];
                localStorage.setItem('usuarioNome', primeiroNome);
                window.location.href = 'tela_depois_cracha.html';
            }

            restartScanner() {
                if (this.isScanning) return;
                
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner jÃ¡ estava parado');
                }
                
                setTimeout(() => {
                    this.startScanner();
                }, 1000);
            }

            showQualityIndicator() {
                const indicator = document.getElementById('qualityIndicator');
                if (indicator) {
                    indicator.style.display = 'block';
                }
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                if (errorDiv) {
                    errorDiv.style.display = 'flex';
                    errorDiv.querySelector('p').textContent = message;
                }
            }

            stop() {
                this.isScanning = false;
                try {
                    Quagga.stop();
                } catch (e) {
                    console.log('Scanner jÃ¡ estava parado');
                }
                
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
            }
        }
        */

        // YOLOv11 Person Detection Class (ONNX)
        class YOLOv11Detector {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isDetecting = false;
                this.personCount = 0;
                this.personRequired = 2; // DetecÃ§Ãµes necessÃ¡rias
                this.statusElement = document.getElementById('statusText');
                this.redirectDelay = 2000; // 2 segundos antes de redirecionar
                this.redirectTimeout = null;
                this.lastDetectionTime = 0;
                this.detectionInterval = 150; // Detectar a cada 150ms
                this.session = null;
                this.inputShape = [1, 3, 640, 640]; // YOLOv11 input shape
                this.config = {
                    minConfidence: 0.5, // 50% de confianÃ§a mÃ­nima
                    nmsThreshold: 0.4, // Non-Maximum Suppression
                    maxDetections: 5, // MÃ¡ximo 5 pessoas
                    realTime: true // Tempo real
                };
                this.classNames = ['person']; // Apenas detecÃ§Ã£o de pessoas
            }

            async init() {
                try {
                    // Solicitar acesso Ã  cÃ¢mera (oculta)
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user' // CÃ¢mera frontal
                        } 
                    });

                    // Criar elementos ocultos para detecÃ§Ã£o
                    this.video = document.createElement('video');
                    this.canvas = document.createElement('canvas');
                    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

                    // Configurar vÃ­deo (oculto)
                    this.video.srcObject = stream;
                    this.video.play();
                    this.video.style.display = 'none';
                    document.body.appendChild(this.video);

                    // Configurar canvas (oculto)
                    this.canvas.width = 200;
                    this.canvas.height = 150;
                    this.canvas.style.display = 'none';
                    document.body.appendChild(this.canvas);

                    // Aguardar vÃ­deo carregar
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Inicializar detecÃ§Ã£o de pessoa
                    await this.initYOLOv11();
                    console.log('DetecÃ§Ã£o de pessoa ativa (oculta)');

                } catch (error) {
                    console.error('Erro ao acessar cÃ¢mera:', error);
                    console.log('DetecÃ§Ã£o de pessoa desabilitada');
                }
            }

            async initYOLOv11() {
                try {
                    // Usar apenas COCO-SSD para evitar problemas de CORS
                    console.log('Carregando COCO-SSD para detecÃ§Ã£o de pessoas...');
                    
                    this.model = await cocoSsd.load({
                        base: 'mobilenet_v2',
                        version: 'lite_mobilenet_v2'
                    });
                    console.log('COCO-SSD carregado com sucesso');
                    this.updateStatus('COCO-SSD ativo - Detectando pessoas...');
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Erro ao carregar COCO-SSD:', error);
                    this.updateStatus('Erro na inicializaÃ§Ã£o - Clique para continuar');
                }
            }

            startDetection() {
                if (!this.video || !this.model) {
                    console.error('VÃ­deo ou modelo nÃ£o inicializado');
                    return;
                }

                const detectPersons = async () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        const now = Date.now();
                        if (now - this.lastDetectionTime > this.detectionInterval) {
                            try {
                                // Usar apenas COCO-SSD
                                const predictions = await this.model.detect(this.video);
                                this.onPersonDetectionResults(predictions);
                                this.lastDetectionTime = now;
                            } catch (error) {
                                console.error('Erro na detecÃ§Ã£o:', error);
                            }
                        }
                    }

                    if (this.isDetecting) {
                        requestAnimationFrame(detectPersons);
                    }
                };

                this.isDetecting = true;
                console.log('Iniciando detecÃ§Ã£o de pessoas...');
                detectPersons();
            }


            onPersonDetectionResults(predictions) {
                // Limpar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Filtrar apenas detecÃ§Ãµes de pessoas com alta confianÃ§a
                const persons = predictions.filter(prediction => 
                    prediction.class === 'person' && 
                    prediction.score > this.config.minConfidence
                );

                if (persons.length > 0) {
                    console.log(`Detectou ${persons.length} pessoa(s)`);
                    
                    // Desenhar informaÃ§Ãµes das pessoas
                    this.drawPersonInformation(persons);

                    // Incrementar contador de pessoas
                    this.personCount++;
                    this.updateStatus(`Pessoa detectada! (${this.personCount}/${this.personRequired})`);
                    
                    if (this.personCount >= this.personRequired) {
                        this.handlePersonDetected();
                    }
                } else {
                    this.personCount = Math.max(0, this.personCount - 1);
                    this.updateStatus('Detectando pessoas...');
                }
            }

            drawPersonInformation(persons) {
                persons.forEach((person, index) => {
                    const { x, y, width, height } = person.bbox;
                    
                    // Escalar coordenadas para o canvas da preview
                    const scaleX = this.canvas.width / this.video.videoWidth;
                    const scaleY = this.canvas.height / this.video.videoHeight;
                    
                    const scaledX = x * scaleX;
                    const scaledY = y * scaleY;
                    const scaledWidth = width * scaleX;
                    const scaledHeight = height * scaleY;

                    // Cores YOLOv11
                    const colors = ['#00FF88', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
                    const color = colors[index % colors.length];
                    const borderColor = color;

                    // Desenhar bounding box da pessoa
                    this.ctx.strokeStyle = borderColor;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);

                    // InformaÃ§Ãµes da pessoa
                    const info = [];
                    info.push(`Pessoa: ${(person.score * 100).toFixed(1)}%`);
                    
                    const labelText = info.join(' | ');
                    const labelWidth = this.ctx.measureText(labelText).width + 10;
                    const labelHeight = 20;
                    
                    // Fundo do label
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY - labelHeight, labelWidth, labelHeight);
                    
                    // Texto do label
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.fillText(labelText, scaledX + 5, scaledY - 5);

                    // Indicador de confianÃ§a
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(scaledX, scaledY + scaledHeight + 2, scaledWidth * person.score, 3);
                });

                // Barra de progresso geral
                const progressWidth = this.canvas.width - 40;
                const progressHeight = 6;
                const progressX = 20;
                const progressY = this.canvas.height - 20;
                
                // Fundo da barra
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Barra de progresso
                const progress = this.personCount / this.personRequired;
                this.ctx.fillStyle = '#00FF88';
                this.ctx.fillRect(progressX, progressY, progressWidth * progress, progressHeight);
            }

            handlePersonDetected() {
                this.updateStatus('Pessoa detectada! Aguardando 5 segundos...');
                this.isDetecting = false;

                // Parar a cÃ¢mera
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                // Contador regressivo de 5 segundos
                let countdown = 5;
                const countdownInterval = setInterval(() => {
                    this.updateStatus(`Pessoa detectada! Redirecionando em ${countdown} segundos...`);
                    countdown--;
                    
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.updateStatus('Pessoa detectada! Redirecionando...');
                        
                        // Alternar para reconhecimento facial apÃ³s 5 segundos
                        setTimeout(() => {
                            switchToFaceDetection();
                        }, 1000);
                    }
                }, 1000);

            }

            updateStatus(message) {
                // Status removido - detecÃ§Ã£o oculta
                console.log('Status:', message);
            }

            // MÃ©todo para otimizar performance do YOLOv11
            optimizeForYOLOv11() {
                // Ajustar configuraÃ§Ãµes baseado na performance
                const fps = 1000 / this.detectionInterval;
                if (fps < 8) {
                    this.detectionInterval = 150; // Reduzir frequÃªncia se muito lento
                    this.config.minConfidence = 0.8; // Aumentar threshold
                } else if (fps > 12) {
                    this.detectionInterval = 80; // Aumentar frequÃªncia se muito rÃ¡pido
                    this.config.minConfidence = 0.6; // Diminuir threshold
                }
            }


            stop() {
                this.isDetecting = false;
                if (this.redirectTimeout) {
                    clearTimeout(this.redirectTimeout);
                }
                // Limpar qualquer countdown ativo
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                // Remover elementos criados dinamicamente
                if (this.video && this.video.parentNode) {
                    this.video.parentNode.removeChild(this.video);
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
            }
        }

        // Scanner de cÃ³digo de barras removido - apenas sistema de voz

        // FunÃ§Ã£o global para reiniciar reconhecimento facial
        function restartFacialRecognition() {
            console.log('ðŸ”„ Reiniciando sistema de reconhecimento facial...');
            
            if (window.faceDetector) {
                // Esconder botÃ£o de reiniciar
                window.faceDetector.hideRestartButton();
                
                // Reiniciar detecÃ§Ã£o
                window.faceDetector.startDetection();
                
                // Resetar tÃ­tulo
                const titleElement = document.querySelector('.scanner-title');
                if (titleElement) {
                    titleElement.textContent = 'Reconhecimento Facial';
                    titleElement.style.color = '#00FFC0';
                    titleElement.style.fontSize = '2rem';
                    titleElement.style.fontWeight = 'normal';
                    titleElement.style.textShadow = 'none';
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('vortexCanvas');
            const sonicWaveform = new SonicWaveformCanvas(canvas);
            window.sonicWaveform = sonicWaveform;

            // Inicializar detector YOLOv11 de pessoas
            const yoloDetector = new YOLOv11Detector();
            yoloDetector.init();

            // Inicializar sistema de reconhecimento facial
            const faceDetector = new CompreFaceDetector();
            window.faceDetector = faceDetector;

            // Handle window resize
            window.addEventListener('resize', () => {
                sonicWaveform.resize();
            });

            // Limpar recursos ao sair da pÃ¡gina
            window.addEventListener('beforeunload', () => {
                sonicWaveform.destroy();
                yoloDetector.stop();
            });
        });

        // Sistema de alternÃ¢ncia entre telas
        let currentScreen = 'idle';
        let faceDetectorInitialized = false;
        let idleTimeout = null;
        const IDLE_TIMEOUT = 30000; // 30 segundos

        function switchToFaceDetection() {
            if (currentScreen === 'face') return;
            
            currentScreen = 'face';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Ocultar tela de descanso
            document.getElementById('idleScreen').style.display = 'none';
            
            // Mostrar tela de reconhecimento facial
            const faceScreen = document.getElementById('scannerScreen');
            faceScreen.style.display = 'flex';
            
            // Ativar animaÃ§Ã£o
            setTimeout(() => {
                faceScreen.classList.add('active');
            }, 50);
            
            // Inicializar detector facial se ainda nÃ£o foi inicializado
            if (!faceDetectorInitialized && window.faceDetector) {
                window.faceDetector.init();
                faceDetectorInitialized = true;
            }
            
            // Configurar timeout para voltar Ã  tela de descanso
            idleTimeout = setTimeout(() => {
                switchToIdle();
            }, IDLE_TIMEOUT);
        }

        function switchToIdle() {
            if (currentScreen === 'idle') return;
            
            currentScreen = 'idle';
            
            // Limpar timeout de inatividade
            if (idleTimeout) {
                clearTimeout(idleTimeout);
                idleTimeout = null;
            }
            
            // Parar detector facial
            if (window.faceDetector) {
                window.faceDetector.stop();
            }
            
            // Ocultar tela de reconhecimento facial
            const faceScreen = document.getElementById('scannerScreen');
            faceScreen.classList.remove('active');
            
            setTimeout(() => {
                faceScreen.style.display = 'none';
                document.getElementById('idleScreen').style.display = 'flex';
            }, 800);
        }

        // Alternar para tela de reconhecimento facial ao clicar
        document.addEventListener('click', function() {
            switchToFaceDetection();
        });

        // Alternar para tela de reconhecimento facial ao tocar (mobile)
        document.addEventListener('touchstart', function() {
            switchToFaceDetection();
        });

        // Prevenir comportamento padrÃ£o de toque
        document.addEventListener('touchend', function(e) {
            e.preventDefault();
        });

    </script>
</body>
</html>
